# Sistema de Mundo e Mapas OTClient

O OTClient implementa um sistema completo de mundo e mapas que gerencia terrenos, tiles, criaturas e pathfinding para criar um ambiente de jogo totalmente funcional.

## üìã √çndice

1. [Vis√£o Geral](#vis√£o-geral)
2. [Arquitetura do Sistema](#arquitetura-do-sistema)
3. [Sistema de Mapas](#sistema-de-mapas)
4. [Sistema de Tiles](#sistema-de-tiles)
5. [Sistema de Criaturas](#sistema-de-criaturas)
6. [Pathfinding](#pathfinding)
7. [Awareness Range](#awareness-range)
8. [MapView e Rendering](#mapview-e-rendering)
9. [Implementa√ß√£o Pr√°tica](#implementa√ß√£o-pr√°tica)
10. [Melhores Pr√°ticas](#melhores-pr√°ticas)

## üéØ Vis√£o Geral

O sistema de mundo do OTClient oferece:

- **Gerenciamento de Mapas**: Carregamento e manipula√ß√£o de mapas OTBM/OTCM
- **Sistema de Tiles**: Organiza√ß√£o hier√°rquica de objetos no mundo
- **Awareness Range**: Otimiza√ß√£o de mem√≥ria e performance
- **Pathfinding**: Algoritmos A* para navega√ß√£o inteligente
- **Multi-Floor**: Suporte completo para m√∫ltiplos andares
- **Editor Integration**: Ferramentas avan√ßadas para edi√ß√£o de mapas

### üèóÔ∏è **Arquitetura do Mundo**

```
Mundo Global (g_map)
   ‚îÇ
   ‚îú‚îÄ Floor 0-15 (FloorData)
   ‚îÇ   ‚îÇ
   ‚îÇ   ‚îú‚îÄ Tile Blocks (32x32)
   ‚îÇ   ‚îÇ   ‚îÇ
   ‚îÇ   ‚îÇ   ‚îú‚îÄ Tiles individuais
   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ
   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Ground
   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Items (empilhados)
   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Creatures
   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ Effects
   ‚îÇ   ‚îÇ   ‚îÇ
   ‚îÇ   ‚îÇ   ‚îî‚îÄ Missiles (efeitos de proj√©til)
   ‚îÇ   ‚îÇ
   ‚îÇ   ‚îî‚îÄ Criaturas (cache global)
   ‚îÇ
   ‚îú‚îÄ MapViews (m√∫ltiplas c√¢meras)
   ‚îú‚îÄ Texts (est√°ticos e animados)
   ‚îî‚îÄ Light System
```

## üó∫Ô∏è Sistema de Mapas

### üì¶ **Classe Map (Singleton Global)**

#### N√≠vel Basic
```cpp
// Acesso global ao mapa
extern Map g_map;

// Inicializa√ß√£o e limpeza
g_map.init();
g_map.terminate();
g_map.clean();
```

#### N√≠vel Intermediate
```cpp
// Acesso global ao mapa
extern Map g_map;

// Inicializa√ß√£o e limpeza
g_map.init();
g_map.terminate();
g_map.clean();
-- Adicionar tratamento de erros
local success, result = pcall(function()
    -- C√≥digo original aqui
end)
if not success then
    print('Erro:', result)
end
```

#### N√≠vel Advanced
```cpp
// Acesso global ao mapa
extern Map g_map;

// Inicializa√ß√£o e limpeza
g_map.init();
g_map.terminate();
g_map.clean();
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### üîß **Opera√ß√µes B√°sicas com Mapas**

```lua
-- Limpar o mapa completamente
    --  Limpar o mapa completamente (traduzido)
g_map.clean()

-- Limpar apenas objetos din√¢micos (criaturas, efeitos)
g_map.cleanDynamicThings()

-- Limpar textos animados e est√°ticos
g_map.cleanTexts()

-- Definir tamanho do mapa
    --  Definir tamanho do mapa (traduzido)
g_map.setSize(1024, 1024)  -- width, height
local mapSize = g_map.getSize()

-- Position central do mapa
    --  Position central do mapa (traduzido)
g_map.setCentralPosition({x = 1000, y = 1000, z = 7})
local centralPos = g_map.getCentralPosition()
```

### üèóÔ∏è **Carregamento de Mapas**

```lua
-- Formatos de mapa suportados
    --  Formatos de mapa suportados (traduzido)
-- OTBM: Formato padr√£o do RME (Remere's Map Editor)
-- OTCM: Formato otimizado do OTClient
    --  OTCM: Formato otimizado do OTClient (traduzido)

-- Em modo editor (FRAMEWORK_EDITOR)
    --  Em modo editor (FRAMEWORK_EDITOR) (traduzido)
g_map.loadOtbm("data/world/map.otbm")
g_map.saveOtbm("data/world/map_export.otbm")

g_map.loadOtcm("data/world/map.otcm")
g_map.saveOtcm("data/world/map_export.otcm")

-- Configurar arquivos auxiliares
    --  Configurar arquivos auxiliares (traduzido)
g_map.setHouseFile("data/world/houses.xml")
g_map.setSpawnFile("data/world/spawns.xml")
g_map.setDescription("Mapa customizado\nCriado com OTClient Editor")
```

## üéØ Sistema de Tiles

### üìê **Estrutura Hier√°rquica**

```cpp
// Organiza√ß√£o de Tiles em Blocos
const int BLOCK_SIZE = 32;  // 32x32 tiles por bloco

class TileBlock {
    -- Classe: TileBlock
    std::array<TilePtr, BLOCK_SIZE * BLOCK_SIZE> m_tiles;
};

// Cada floor cont√©m m√∫ltiplos TileBlocks
struct FloorData {
    std::unordered_map<uint32_t, TileBlock> tileBlocks;
    std::vector<MissilePtr> missiles;
};
```

### üî® **Manipula√ß√£o de Tiles**

#### N√≠vel Basic
```lua
-- Obter tile em uma posi√ß√£o
local tile = g_map.getTile({x = 1000, y = 1000, z = 7})
-- Criar tile se n√£o existir
local tile = g_map.getOrCreateTile({x = 1000, y = 1000, z = 7})
-- Criar tile vazio
local tile = g_map.createTile({x = 1000, y = 1000, z = 7})
-- Limpar tile espec√≠fico
-- Verificar se tile existe
if tile then
    print("Tile existe na posi√ß√£o")
end
-- Listar todos os tiles de um floor
local tiles = g_map.getTiles(7)  -- floor 7
    print("Tile encontrado:", tile:getPosition())
end
```

#### N√≠vel Intermediate
```lua
-- Obter tile em uma posi√ß√£o
local tile = g_map.getTile({x = 1000, y = 1000, z = 7})

-- Criar tile se n√£o existir
local tile = g_map.getOrCreateTile({x = 1000, y = 1000, z = 7})

-- Criar tile vazio
local tile = g_map.createTile({x = 1000, y = 1000, z = 7})

-- Limpar tile espec√≠fico
g_map.cleanTile({x = 1000, y = 1000, z = 7})

-- Verificar se tile existe
if tile then
    print("Tile existe na posi√ß√£o")
end

-- Listar todos os tiles de um floor
local tiles = g_map.getTiles(7)  -- floor 7
for _, tile in ipairs(tiles) do
    print("Tile encontrado:", tile:getPosition())
end
```

#### N√≠vel Advanced
```lua
-- Obter tile em uma posi√ß√£o
local tile = g_map.getTile({x = 1000, y = 1000, z = 7})

-- Criar tile se n√£o existir
local tile = g_map.getOrCreateTile({x = 1000, y = 1000, z = 7})

-- Criar tile vazio
local tile = g_map.createTile({x = 1000, y = 1000, z = 7})

-- Limpar tile espec√≠fico
g_map.cleanTile({x = 1000, y = 1000, z = 7})

-- Verificar se tile existe
if tile then
    print("Tile existe na posi√ß√£o")
end

-- Listar todos os tiles de um floor
local tiles = g_map.getTiles(7)  -- floor 7
for _, tile in ipairs(tiles) do
    print("Tile encontrado:", tile:getPosition())
end
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### üì¶ **Manipula√ß√£o de Objetos nos Tiles**

#### N√≠vel Basic
```lua
-- Adicionar objeto a um tile
local item = Item.create(1234)  -- ID do item
-- Remover objeto espec√≠fico
-- Remover por posi√ß√£o e stack
-- Obter objeto de um tile
local thing = g_map.getThing({x = 1000, y = 1000, z = 7}, 0)
-- Procurar itens por ID
local items = g_map.findItemsById(1234, 100)  -- ID, m√°ximo
    print("Item encontrado em:", pos)
end
```

#### N√≠vel Intermediate
```lua
-- Adicionar objeto a um tile
local item = Item.create(1234)  -- ID do item
g_map.addThing(item, {x = 1000, y = 1000, z = 7}, -1)  -- stackPos -1 = topo

-- Remover objeto espec√≠fico
g_map.removeThing(item)

-- Remover por posi√ß√£o e stack
g_map.removeThingByPos({x = 1000, y = 1000, z = 7}, 0)  -- stackPos 0

-- Obter objeto de um tile
local thing = g_map.getThing({x = 1000, y = 1000, z = 7}, 0)

-- Procurar itens por ID
local items = g_map.findItemsById(1234, 100)  -- ID, m√°ximo
for pos, item in pairs(items) do
    print("Item encontrado em:", pos)
end
```

#### N√≠vel Advanced
```lua
-- Adicionar objeto a um tile
local item = Item.create(1234)  -- ID do item
g_map.addThing(item, {x = 1000, y = 1000, z = 7}, -1)  -- stackPos -1 = topo

-- Remover objeto espec√≠fico
g_map.removeThing(item)

-- Remover por posi√ß√£o e stack
g_map.removeThingByPos({x = 1000, y = 1000, z = 7}, 0)  -- stackPos 0

-- Obter objeto de um tile
local thing = g_map.getThing({x = 1000, y = 1000, z = 7}, 0)

-- Procurar itens por ID
local items = g_map.findItemsById(1234, 100)  -- ID, m√°ximo
for pos, item in pairs(items) do
    print("Item encontrado em:", pos)
end
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### üé® **Propriedades dos Tiles**

#### N√≠vel Basic
```lua
local tile = g_map.getTile({x = 1000, y = 1000, z = 7})
if tile then
    -- Verificar propriedades
    local isWalkable = tile:isWalkable()
    local isPathable = tile:isPathable()
    local hasCreature = tile:hasCreature()
    local hasGround = tile:hasGround()
    -- Obter ground (ch√£o)
    local ground = tile:getGround()
    -- Contar objetos
    local thingCount = tile:getThingCount()
    -- Obter eleva√ß√£o
    local elevation = tile:getElevation()
    -- Verificar se bloqueia proj√©teis
    local blocksProjectile = tile:isBlockProjectile()
    -- Obter todos os objetos
    local things = tile:getThings()
        print("Objeto " .. i .. ":", thing:getId())
    end
end
```

#### N√≠vel Intermediate
```lua
local tile = g_map.getTile({x = 1000, y = 1000, z = 7})
if tile then
    -- Verificar propriedades
    local isWalkable = tile:isWalkable()
    local isPathable = tile:isPathable()
    local hasCreature = tile:hasCreature()
    local hasGround = tile:hasGround()
    
    -- Obter ground (ch√£o)
    local ground = tile:getGround()
    
    -- Contar objetos
    local thingCount = tile:getThingCount()
    
    -- Obter eleva√ß√£o
    local elevation = tile:getElevation()
    
    -- Verificar se bloqueia proj√©teis
    local blocksProjectile = tile:isBlockProjectile()
    
    -- Obter todos os objetos
    local things = tile:getThings()
    for i, thing in ipairs(things) do
        print("Objeto " .. i .. ":", thing:getId())
    end
end
```

#### N√≠vel Advanced
```lua
local tile = g_map.getTile({x = 1000, y = 1000, z = 7})
if tile then
    -- Verificar propriedades
    local isWalkable = tile:isWalkable()
    local isPathable = tile:isPathable()
    local hasCreature = tile:hasCreature()
    local hasGround = tile:hasGround()
    
    -- Obter ground (ch√£o)
    local ground = tile:getGround()
    
    -- Contar objetos
    local thingCount = tile:getThingCount()
    
    -- Obter eleva√ß√£o
    local elevation = tile:getElevation()
    
    -- Verificar se bloqueia proj√©teis
    local blocksProjectile = tile:isBlockProjectile()
    
    -- Obter todos os objetos
    local things = tile:getThings()
    for i, thing in ipairs(things) do
        print("Objeto " .. i .. ":", thing:getId())
    end
end
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

## üë• Sistema de Criaturas

### üîç **Gerenciamento de Criaturas**

```lua
-- Adicionar criatura ao mapa
    --  Adicionar criatura ao mapa (traduzido)
local creature = Creature.create()
creature:setName("Demon")
creature:setId(12345)
g_map.addCreature(creature)

-- Buscar criatura por ID
    --  Buscar criatura por ID (traduzido)
local creature = g_map.getCreatureById(12345)
if creature then
    -- Verifica√ß√£o condicional
    print("Criatura encontrada:", creature:getName())
end

-- Remover criatura
    --  Remover criatura (traduzido)
g_map.removeCreatureById(12345)

-- Obter todas as criaturas
    --  Obter todas as criaturas (traduzido)
local creatures = g_map.getCreatures()
for id, creature in pairs(creatures) do
    -- Loop de repeti√ß√£o
    print("Criatura ID " .. id .. ":", creature:getName())
end
```

### üëÄ **Sistema de Spectators**

#### N√≠vel Basic
```lua
-- Posi√ß√£o central
local centerPos = {x = 1000, y = 1000, z = 7}
-- Buscar spectators (criaturas vis√≠veis)
local spectators = g_map.getSpectators(centerPos, true)  -- multiFloor = true
    print("Spectator:", creature:getName())
end
-- Buscar spectators para vis√£o
local sightSpectators = g_map.getSightSpectators(centerPos, false)
-- Buscar em range customizado
local rangeSpectators = g_map.getSpectatorsInRange(centerPos, true, 5, 5)
-- Buscar em range assim√©trico
local asymmetricSpectators = g_map.getSpectatorsInRangeEx(
-- Buscar por padr√£o
local patternSpectators = g_map.getSpectatorsByPattern(
```

#### N√≠vel Intermediate
```lua
-- Posi√ß√£o central
local centerPos = {x = 1000, y = 1000, z = 7}

-- Buscar spectators (criaturas vis√≠veis)
local spectators = g_map.getSpectators(centerPos, true)  -- multiFloor = true
for _, creature in ipairs(spectators) do
    print("Spectator:", creature:getName())
end

-- Buscar spectators para vis√£o
local sightSpectators = g_map.getSightSpectators(centerPos, false)

-- Buscar em range customizado
local rangeSpectators = g_map.getSpectatorsInRange(centerPos, true, 5, 5)

-- Buscar em range assim√©trico
local asymmetricSpectators = g_map.getSpectatorsInRangeEx(
    centerPos, true,  -- posi√ß√£o, multiFloor
    3, 7,             -- minX, maxX
    2, 5              -- minY, maxY
)

-- Buscar por padr√£o
local patternSpectators = g_map.getSpectatorsByPattern(
    centerPos, 
    "Demon.*",        -- regex pattern
    Otc.North         -- dire√ß√£o
)
```

#### N√≠vel Advanced
```lua
-- Posi√ß√£o central
local centerPos = {x = 1000, y = 1000, z = 7}

-- Buscar spectators (criaturas vis√≠veis)
local spectators = g_map.getSpectators(centerPos, true)  -- multiFloor = true
for _, creature in ipairs(spectators) do
    print("Spectator:", creature:getName())
end

-- Buscar spectators para vis√£o
local sightSpectators = g_map.getSightSpectators(centerPos, false)

-- Buscar em range customizado
local rangeSpectators = g_map.getSpectatorsInRange(centerPos, true, 5, 5)

-- Buscar em range assim√©trico
local asymmetricSpectators = g_map.getSpectatorsInRangeEx(
    centerPos, true,  -- posi√ß√£o, multiFloor
    3, 7,             -- minX, maxX
    2, 5              -- minY, maxY
)

-- Buscar por padr√£o
local patternSpectators = g_map.getSpectatorsByPattern(
    centerPos, 
    "Demon.*",        -- regex pattern
    Otc.North         -- dire√ß√£o
)
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

## üõ§Ô∏è Pathfinding

### üß≠ **Sistema de Navega√ß√£o**

```lua
-- Encontrar caminho b√°sico
local startPos = {x = 1000, y = 1000, z = 7}
local goalPos = {x = 1010, y = 1010, z = 7}

local path, result = g_map.findPath(startPos, goalPos, 100)  -- maxComplexity

if result == Otc.PathFindResultOk then
    -- Verifica√ß√£o condicional
    print("Caminho encontrado!")
    for i, direction in ipairs(path) do
    -- Loop de repeti√ß√£o
        print("Passo " .. i .. ":", Otc.DirectionToString(direction))
    end
else
    print("Caminho n√£o encontrado:", result)
end

-- Resultados poss√≠veis
-- Otc.PathFindResultOk           - Sucesso
    --  Otc.PathFindResultOk           - Sucesso (traduzido)
-- Otc.PathFindResultNoWay        - Sem caminho
    --  Otc.PathFindResultNoWay        - Sem caminho (traduzido)
-- Otc.PathFindResultTooFar       - Muito distante
    --  Otc.PathFindResultTooFar       - Muito distante (traduzido)
-- Otc.PathFindResultTooManySteps - Muitos passos
    --  Otc.PathFindResultTooManySteps - Muitos passos (traduzido)
```

### ‚ö° **Pathfinding Ass√≠ncrono**

```lua
-- Encontrar caminho em background
    --  Encontrar caminho em background (traduzido)
g_map.findPathAsync(startPos, goalPos, function(result)
    if result.status == Otc.PathFindResultOk then
    -- Verifica√ß√£o condicional
        print("Caminho ass√≠ncrono encontrado!")
        print("Complexidade:", result.complexity)
        
        for i, direction in ipairs(result.path) do
    -- Loop de repeti√ß√£o
            print("Dire√ß√£o " .. i .. ":", direction)
        end
    else
        print("Falha no pathfinding:", result.status)
    end
end)
```

### üîç **Pathfinding Avan√ßado**

#### N√≠vel Basic
```lua
-- Encontrar m√∫ltiplos caminhos
local paths = g_map.findEveryPath(
    local steps, cost, time, description = table.unpack(pathData)
    print(pathName .. ":", steps .. " passos, custo " .. cost)
end
-- Verificar linha de vis√£o
local canSee = g_map.isSightClear(
if canSee then
    print("Linha de vis√£o livre")
    print("Vis√£o bloqueada")
end
```

#### N√≠vel Intermediate
```lua
-- Encontrar m√∫ltiplos caminhos
local paths = g_map.findEveryPath(
    startPos,
    50,  -- dist√¢ncia m√°xima
    {
        avoid_creatures = "true",
        avoid_fields = "true",
        allow_diagonal = "false"
    }
)

for pathName, pathData in pairs(paths) do
    local steps, cost, time, description = table.unpack(pathData)
    print(pathName .. ":", steps .. " passos, custo " .. cost)
end

-- Verificar linha de vis√£o
local canSee = g_map.isSightClear(
    {x = 1000, y = 1000, z = 7},
    {x = 1005, y = 1005, z = 7}
)

if canSee then
    print("Linha de vis√£o livre")
else
    print("Vis√£o bloqueada")
end
```

#### N√≠vel Advanced
```lua
-- Encontrar m√∫ltiplos caminhos
local paths = g_map.findEveryPath(
    startPos,
    50,  -- dist√¢ncia m√°xima
    {
        avoid_creatures = "true",
        avoid_fields = "true",
        allow_diagonal = "false"
    }
)

for pathName, pathData in pairs(paths) do
    local steps, cost, time, description = table.unpack(pathData)
    print(pathName .. ":", steps .. " passos, custo " .. cost)
end

-- Verificar linha de vis√£o
local canSee = g_map.isSightClear(
    {x = 1000, y = 1000, z = 7},
    {x = 1005, y = 1005, z = 7}
)

if canSee then
    print("Linha de vis√£o livre")
else
    print("Vis√£o bloqueada")
end
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

## üì° Awareness Range

### üéØ **Gerenciamento de Alcance**

#### N√≠vel Basic
```lua
-- Obter awareness range atual
local awareRange = g_map.getAwareRange()
print("Aware Range:", awareRange.left, awareRange.right, awareRange.top, awareRange.bottom)
-- Definir awareness range customizado
-- Resetar para o padr√£o
-- Verificar se posi√ß√£o est√° no aware range
local pos = {x = 1000, y = 1000, z = 7}
local isAware = g_map.isAwareOfPosition(pos)
if isAware then
    print("Posi√ß√£o est√° no range de awareness")
    print("Posi√ß√£o fora do awareness range")
end
```

#### N√≠vel Intermediate
```lua
-- Obter awareness range atual
local awareRange = g_map.getAwareRange()
print("Aware Range:", awareRange.left, awareRange.right, awareRange.top, awareRange.bottom)

-- Definir awareness range customizado
g_map.setAwareRange({
    left = 8,      -- tiles √† esquerda
    right = 9,     -- tiles √† direita  
    top = 6,       -- tiles acima
    bottom = 7     -- tiles abaixo
})

-- Resetar para o padr√£o
g_map.resetAwareRange()

-- Verificar se posi√ß√£o est√° no aware range
local pos = {x = 1000, y = 1000, z = 7}
local isAware = g_map.isAwareOfPosition(pos)

if isAware then
    print("Posi√ß√£o est√° no range de awareness")
else
    print("Posi√ß√£o fora do awareness range")
end
```

#### N√≠vel Advanced
```lua
-- Obter awareness range atual
local awareRange = g_map.getAwareRange()
print("Aware Range:", awareRange.left, awareRange.right, awareRange.top, awareRange.bottom)

-- Definir awareness range customizado
g_map.setAwareRange({
    left = 8,      -- tiles √† esquerda
    right = 9,     -- tiles √† direita  
    top = 6,       -- tiles acima
    bottom = 7     -- tiles abaixo
})

-- Resetar para o padr√£o
g_map.resetAwareRange()

-- Verificar se posi√ß√£o est√° no aware range
local pos = {x = 1000, y = 1000, z = 7}
local isAware = g_map.isAwareOfPosition(pos)

if isAware then
    print("Posi√ß√£o est√° no range de awareness")
else
    print("Posi√ß√£o fora do awareness range")
end
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### üåü **Floor Awareness**

#### N√≠vel Basic
```lua
-- Obter range de floors vis√≠veis
local firstFloor = g_map.getFirstAwareFloor()
local lastFloor = g_map.getLastAwareFloor()

print("Floors vis√≠veis:", firstFloor .. " a " .. lastFloor)

-- Verificar cobertura de posi√ß√£o
local pos = {x = 1000, y = 1000, z = 7}

-- Verificar se est√° coberto
local isCovered = g_map.isCovered(pos, 0)  -- firstFloor = 0

-- Verificar se est√° completamente coberto
local isCompletelyCovered = g_map.isCompletelyCovered(pos, 0)

-- Verificar se √© poss√≠vel olhar
local canLook = g_map.isLookPossible(pos)

print("Coberto:", isCovered)
print("Completamente coberto:", isCompletelyCovered)
print("Pode olhar:", canLook)
```

#### N√≠vel Intermediate
```lua
-- Obter range de floors vis√≠veis
local firstFloor = g_map.getFirstAwareFloor()
local lastFloor = g_map.getLastAwareFloor()

print("Floors vis√≠veis:", firstFloor .. " a " .. lastFloor)

-- Verificar cobertura de posi√ß√£o
local pos = {x = 1000, y = 1000, z = 7}

-- Verificar se est√° coberto
local isCovered = g_map.isCovered(pos, 0)  -- firstFloor = 0

-- Verificar se est√° completamente coberto
local isCompletelyCovered = g_map.isCompletelyCovered(pos, 0)

-- Verificar se √© poss√≠vel olhar
local canLook = g_map.isLookPossible(pos)

print("Coberto:", isCovered)
print("Completamente coberto:", isCompletelyCovered)
print("Pode olhar:", canLook)
-- Adicionar tratamento de erros
local success, result = pcall(function()
    -- C√≥digo original aqui
end)
if not success then
    print('Erro:', result)
end
```

#### N√≠vel Advanced
```lua
-- Obter range de floors vis√≠veis
local firstFloor = g_map.getFirstAwareFloor()
local lastFloor = g_map.getLastAwareFloor()

print("Floors vis√≠veis:", firstFloor .. " a " .. lastFloor)

-- Verificar cobertura de posi√ß√£o
local pos = {x = 1000, y = 1000, z = 7}

-- Verificar se est√° coberto
local isCovered = g_map.isCovered(pos, 0)  -- firstFloor = 0

-- Verificar se est√° completamente coberto
local isCompletelyCovered = g_map.isCompletelyCovered(pos, 0)

-- Verificar se √© poss√≠vel olhar
local canLook = g_map.isLookPossible(pos)

print("Coberto:", isCovered)
print("Completamente coberto:", isCompletelyCovered)
print("Pode olhar:", canLook)
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

## üé• MapView e Rendering

### üìπ **Sistema de M√∫ltiplas C√¢meras**

#### N√≠vel Basic
```lua
-- MapViews s√£o gerenciadas automaticamente pelo sistema
-- Cada widget de mapa possui sua pr√≥pria MapView

-- A MapView principal √© criada automaticamente
-- M√∫ltiplas MapViews permitem:
-- - M√∫ltiplas janelas de mapa
-- - Mini-mapas
-- - Picture-in-picture
-- - Diferentes seguimentos de criaturas

-- Resetar c√¢mera da MapView
g_map.resetLastCamera()

-- Notificar movimento da c√¢mera
g_map.notificateCameraMove({x = 10, y = 5})  -- offset em pixels
```

#### N√≠vel Intermediate
```lua
-- MapViews s√£o gerenciadas automaticamente pelo sistema
-- Cada widget de mapa possui sua pr√≥pria MapView

-- A MapView principal √© criada automaticamente
-- M√∫ltiplas MapViews permitem:
-- - M√∫ltiplas janelas de mapa
-- - Mini-mapas
-- - Picture-in-picture
-- - Diferentes seguimentos de criaturas

-- Resetar c√¢mera da MapView
g_map.resetLastCamera()

-- Notificar movimento da c√¢mera
g_map.notificateCameraMove({x = 10, y = 5})  -- offset em pixels
-- Adicionar tratamento de erros
local success, result = pcall(function()
    -- C√≥digo original aqui
end)
if not success then
    print('Erro:', result)
end
```

#### N√≠vel Advanced
```lua
-- MapViews s√£o gerenciadas automaticamente pelo sistema
-- Cada widget de mapa possui sua pr√≥pria MapView

-- A MapView principal √© criada automaticamente
-- M√∫ltiplas MapViews permitem:
-- - M√∫ltiplas janelas de mapa
-- - Mini-mapas
-- - Picture-in-picture
-- - Diferentes seguimentos de criaturas

-- Resetar c√¢mera da MapView
g_map.resetLastCamera()

-- Notificar movimento da c√¢mera
g_map.notificateCameraMove({x = 10, y = 5})  -- offset em pixels
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### üí° **Sistema de Ilumina√ß√£o**

#### N√≠vel Basic
```lua
-- Definir luz global do mapa
g_map.setLight({
    intensity = 255,    -- 0-255
    color = 215        -- cor da luz
})

-- Obter configura√ß√£o atual de luz
local light = g_map.getLight()
print("Intensidade da luz:", light.intensity)
print("Cor da luz:", light.color)

-- Ghost mode (transpar√™ncia)
g_map.beginGhostMode(0.5)  -- 50% transpar√™ncia
-- ... fazer opera√ß√µes ...
g_map.endGhostMode()
```

#### N√≠vel Intermediate
```lua
-- Definir luz global do mapa
g_map.setLight({
    intensity = 255,    -- 0-255
    color = 215        -- cor da luz
})

-- Obter configura√ß√£o atual de luz
local light = g_map.getLight()
print("Intensidade da luz:", light.intensity)
print("Cor da luz:", light.color)

-- Ghost mode (transpar√™ncia)
g_map.beginGhostMode(0.5)  -- 50% transpar√™ncia
-- ... fazer opera√ß√µes ...
g_map.endGhostMode()
-- Adicionar tratamento de erros
local success, result = pcall(function()
    -- C√≥digo original aqui
end)
if not success then
    print('Erro:', result)
end
```

#### N√≠vel Advanced
```lua
-- Definir luz global do mapa
g_map.setLight({
    intensity = 255,    -- 0-255
    color = 215        -- cor da luz
})

-- Obter configura√ß√£o atual de luz
local light = g_map.getLight()
print("Intensidade da luz:", light.intensity)
print("Cor da luz:", light.color)

-- Ghost mode (transpar√™ncia)
g_map.beginGhostMode(0.5)  -- 50% transpar√™ncia
-- ... fazer opera√ß√µes ...
g_map.endGhostMode()
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### üé® **Coloriza√ß√£o e Efeitos**

```lua
-- Colorizar objetos
    --  Colorizar objetos (traduzido)
local item = g_map.getThing({x = 1000, y = 1000, z = 7}, 0)
if item then
    -- Verifica√ß√£o condicional
    g_map.colorizeThing(item, '#FF0000')  -- vermelho
end

-- Remover coloriza√ß√£o
g_map.removeThingColor(item)

-- Controlar efeitos flutuantes
    --  Controlar efeitos flutuantes (traduzido)
g_map.setFloatingEffect(true)
local hasFloatingEffects = g_map.isDrawingFloatingEffects()
```

## üìù Textos no Mundo

### üìú **Textos Est√°ticos**

#### N√≠vel Basic
```lua
-- Adicionar texto est√°tico
local staticText = StaticText.create()
-- Remover texto est√°tico
-- Buscar texto em posi√ß√£o
local foundText = g_map.getStaticText({x = 1000, y = 1000, z = 7})
if foundText then
    print("Texto encontrado:", foundText:getText())
end
-- Obter todos os textos est√°ticos
local staticTexts = g_map.getStaticTexts()
    print("Texto est√°tico:", text:getText())
end
```

#### N√≠vel Intermediate
```lua
-- Adicionar texto est√°tico
local staticText = StaticText.create()
staticText:setText("Loja de Armas")
staticText:setFont("verdana-11px-rounded")
staticText:setColor('#FFFF00')

g_map.addStaticText(staticText, {x = 1000, y = 1000, z = 7})

-- Remover texto est√°tico
g_map.removeStaticText(staticText)

-- Buscar texto em posi√ß√£o
local foundText = g_map.getStaticText({x = 1000, y = 1000, z = 7})
if foundText then
    print("Texto encontrado:", foundText:getText())
end

-- Obter todos os textos est√°ticos
local staticTexts = g_map.getStaticTexts()
for _, text in ipairs(staticTexts) do
    print("Texto est√°tico:", text:getText())
end
```

#### N√≠vel Advanced
```lua
-- Adicionar texto est√°tico
local staticText = StaticText.create()
staticText:setText("Loja de Armas")
staticText:setFont("verdana-11px-rounded")
staticText:setColor('#FFFF00')

g_map.addStaticText(staticText, {x = 1000, y = 1000, z = 7})

-- Remover texto est√°tico
g_map.removeStaticText(staticText)

-- Buscar texto em posi√ß√£o
local foundText = g_map.getStaticText({x = 1000, y = 1000, z = 7})
if foundText then
    print("Texto encontrado:", foundText:getText())
end

-- Obter todos os textos est√°ticos
local staticTexts = g_map.getStaticTexts()
for _, text in ipairs(staticTexts) do
    print("Texto est√°tico:", text:getText())
end
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### ‚ú® **Textos Animados**

```lua
-- Adicionar texto animado
    --  Adicionar texto animado (traduzido)
local animatedText = AnimatedText.create()
animatedText:setText("+50 EXP")
animatedText:setColor('#00FF00')
animatedText:setOffset({x = 0, y = -20})  -- movimento

g_map.addAnimatedText(animatedText, {x = 1000, y = 1000, z = 7})

-- Remover texto animado
    --  Remover texto animado (traduzido)
g_map.removeAnimatedText(animatedText)

-- Obter todos os textos animados
    --  Obter todos os textos animados (traduzido)
local animatedTexts = g_map.getAnimatedTexts()
for _, text in ipairs(animatedTexts) do
    -- Loop de repeti√ß√£o
    print("Texto animado:", text:getText())
end
```

## üéØ Implementa√ß√£o Pr√°tica

### üè∞ **Sistema de Casas (Editor Mode)**

#### N√≠vel Basic
```lua
-- Configura√ß√£o de zonas em modo editor
g_map.setShowZones(true)
g_map.setZoneOpacity(0.7)

-- Configurar cores de zona
g_map.setZoneColor(TILESTATE_HOUSE, '#0000FF')           -- azul para casas
g_map.setZoneColor(TILESTATE_PROTECTIONZONE, '#00FF00') -- verde para PZ
g_map.setZoneColor(TILESTATE_OPTIONALZONE, '#FFFF00')   -- amarelo para optional

-- Mostrar zona espec√≠fica
g_map.setShowZone(TILESTATE_HOUSE, true)

-- Verificar configura√ß√µes
local showingZones = g_map.showZones()
local houseColor = g_map.getZoneColor(TILESTATE_HOUSE)
print("Mostrando zonas:", showingZones)
```

#### N√≠vel Intermediate
```lua
-- Configura√ß√£o de zonas em modo editor
g_map.setShowZones(true)
g_map.setZoneOpacity(0.7)

-- Configurar cores de zona
g_map.setZoneColor(TILESTATE_HOUSE, '#0000FF')           -- azul para casas
g_map.setZoneColor(TILESTATE_PROTECTIONZONE, '#00FF00') -- verde para PZ
g_map.setZoneColor(TILESTATE_OPTIONALZONE, '#FFFF00')   -- amarelo para optional

-- Mostrar zona espec√≠fica
g_map.setShowZone(TILESTATE_HOUSE, true)

-- Verificar configura√ß√µes
local showingZones = g_map.showZones()
local houseColor = g_map.getZoneColor(TILESTATE_HOUSE)
print("Mostrando zonas:", showingZones)
-- Adicionar tratamento de erros
local success, result = pcall(function()
    -- C√≥digo original aqui
end)
if not success then
    print('Erro:', result)
end
```

#### N√≠vel Advanced
```lua
-- Configura√ß√£o de zonas em modo editor
g_map.setShowZones(true)
g_map.setZoneOpacity(0.7)

-- Configurar cores de zona
g_map.setZoneColor(TILESTATE_HOUSE, '#0000FF')           -- azul para casas
g_map.setZoneColor(TILESTATE_PROTECTIONZONE, '#00FF00') -- verde para PZ
g_map.setZoneColor(TILESTATE_OPTIONALZONE, '#FFFF00')   -- amarelo para optional

-- Mostrar zona espec√≠fica
g_map.setShowZone(TILESTATE_HOUSE, true)

-- Verificar configura√ß√µes
local showingZones = g_map.showZones()
local houseColor = g_map.getZoneColor(TILESTATE_HOUSE)
print("Mostrando zonas:", showingZones)
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### üìä **Sistema de Minimapa**

#### N√≠vel Basic
```lua
-- Obter cor do minimapa para posi√ß√£o
local minimapColor = g_map.getMinimapColor({x = 1000, y = 1000, z = 7})
print("Cor do minimapa:", minimapColor)

-- Cores de minimapa t√≠picas:
-- 0   = Preto (vazio)
-- 88  = Verde (grama)
-- 188 = Marrom (terra)
-- 208 = Azul (√°gua)
-- 18  = Cinza (pedra)
```

#### N√≠vel Intermediate
```lua
-- Obter cor do minimapa para posi√ß√£o
local minimapColor = g_map.getMinimapColor({x = 1000, y = 1000, z = 7})
print("Cor do minimapa:", minimapColor)

-- Cores de minimapa t√≠picas:
-- 0   = Preto (vazio)
-- 88  = Verde (grama)
-- 188 = Marrom (terra)
-- 208 = Azul (√°gua)
-- 18  = Cinza (pedra)
-- Adicionar tratamento de erros
local success, result = pcall(function()
    -- C√≥digo original aqui
end)
if not success then
    print('Erro:', result)
end
```

#### N√≠vel Advanced
```lua
-- Obter cor do minimapa para posi√ß√£o
local minimapColor = g_map.getMinimapColor({x = 1000, y = 1000, z = 7})
print("Cor do minimapa:", minimapColor)

-- Cores de minimapa t√≠picas:
-- 0   = Preto (vazio)
-- 88  = Verde (grama)
-- 188 = Marrom (terra)
-- 208 = Azul (√°gua)
-- 18  = Cinza (pedra)
-- Adicionar metatable para funcionalidade avan√ßada
local mt = {
    __index = function(t, k)
        return rawget(t, k) or 'Valor n√£o encontrado'
    end
    __call = function(t, ...)
        print('Objeto chamado com:', ...)
    end
}
setmetatable(meuObjeto, mt)
```

### üéÆ **Sistema de Jogo Integrado**

#### Inicializa√ß√£o e Configura√ß√£o
```lua
-- Exemplo: Sistema de Teleporte
function teleportPlayer(targetPos)
    local player = g_game.getLocalPlayer()
    if not player then return end
    
    local currentPos = player:getPosition()
    
    -- Verificar se posi√ß√£o de destino √© v√°lida
    if not g_map.isLookPossible(targetPos) then
        print("Posi√ß√£o de destino inv√°lida")
        return
    end
    
    -- Limpar tile atual
    g_map.removeThing(player)
    
    -- Adicionar na nova posi√ß√£o
    g_map.addThing(player, targetPos)
    
    -- Atualizar posi√ß√£o central
    g_map.setCentralPosition(targetPos)
    
    print("Jogador teleportado de", currentPos, "para", targetPos)
end
```

#### Funcionalidade 1
```lua

-- Exemplo: Sistema de Busca de Itens
function findNearbyItems(centerPos, itemId, radius)
    local foundItems = {}
    
    for x = centerPos.x - radius, centerPos.x + radius do
        for y = centerPos.y - radius, centerPos.y + radius do
            local pos = {x = x, y = y, z = centerPos.z}
            local tile = g_map.getTile(pos)
            
            if tile then
                local things = tile:getThings()
                for _, thing in ipairs(things) do
                    if thing:isItem() and thing:getId() == itemId then
                        table.insert(foundItems, {pos = pos, item = thing})
                    end
                end
            end
        end
    end
    
    return foundItems
end
```

#### Finaliza√ß√£o
```lua

-- Uso
local items = findNearbyItems({x = 1000, y = 1000, z = 7}, 1234, 5)
print("Encontrados " .. #items .. " itens")
```

## ‚úÖ Melhores Pr√°ticas

### üõ°Ô∏è **Performance e Otimiza√ß√£o**

```lua
-- ‚úÖ BOM: Verificar exist√™ncia antes de usar
local function safeTileAccess(pos)
    local tile = g_map.getTile(pos)
    if not tile then
    -- Verifica√ß√£o condicional
        return nil
    end
    
    return tile:getThings()
end

-- ‚úÖ BOM: Cache de tiles frequentemente acessados
    --  ‚úÖ BOM: Cache de tiles frequentemente acessados (traduzido)
local tileCache = {}

local function getCachedTile(pos)
    local key = pos.x .. "," .. pos.y .. "," .. pos.z
    
    if not tileCache[key] then
    -- Verifica√ß√£o condicional
        tileCache[key] = g_map.getTile(pos)
    end
    
    return tileCache[key]
end

-- ‚úÖ BOM: Limitar range de busca
    --  ‚úÖ BOM: Limitar range de busca (traduzido)
local function findItemsInRange(centerPos, itemId, maxRange)
    maxRange = math.min(maxRange, 20)  -- limitar busca
    -- ... implementa√ß√£o ...
end

-- ‚ùå EVITE: Iterar sobre todo o mapa
    --  ‚ùå EVITE: Iterar sobre todo o mapa (traduzido)
local function findAllItems(itemId)  -- LENTO!
    for x = 0, 2048 do
    -- Loop de repeti√ß√£o
        for y = 0, 2048 do
    -- Loop de repeti√ß√£o
            -- muito custoso
    --  muito custoso (traduzido)
        end
    end
end
```

### üîí **Valida√ß√£o e Seguran√ßa**

```lua
-- ‚úÖ BOM: Sempre validar posi√ß√µes
local function isValidPosition(pos)
    return pos and 
           type(pos.x) == 'number' and 
           type(pos.y) == 'number' and 
           type(pos.z) == 'number' and
           pos.x >= 0 and pos.x <= 65535 and
           pos.y >= 0 and pos.y <= 65535 and
           pos.z >= 0 and pos.z <= 15
end

-- ‚úÖ BOM: Verificar awareness range
    --  ‚úÖ BOM: Verificar awareness range (traduzido)
local function isPositionVisible(pos)
    return g_map.isAwareOfPosition(pos) and 
           g_map.isLookPossible(pos)
end

-- ‚úÖ BOM: Cleanup apropriado
    --  ‚úÖ BOM: Cleanup apropriado (traduzido)
local function cleanupMap()
    g_map.cleanDynamicThings()  -- preserva mapa base
    g_map.cleanTexts()          -- remove textos tempor√°rios
end
```

### üéØ **Pathfinding Eficiente**

```lua
-- ‚úÖ BOM: Usar complexidade apropriada
    --  ‚úÖ BOM: Usar complexidade apropriada (traduzido)
local function findPathSmart(start, goal)
    local distance = math.abs(start.x - goal.x) + math.abs(start.y - goal.y)
    local complexity = math.min(distance * 2, 500)  -- adaptivo
    
    return g_map.findPath(start, goal, complexity)
end

-- ‚úÖ BOM: Cache de pathfinding
    --  ‚úÖ BOM: Cache de pathfinding (traduzido)
local pathCache = {}
local CACHE_DURATION = 5000  -- 5 segundos

local function getCachedPath(start, goal)
    local key = start.x .. "," .. start.y .. "->" .. goal.x .. "," .. goal.y
    local cached = pathCache[key]
    
    if cached and g_clock.millis() - cached.time < CACHE_DURATION then
    -- Verifica√ß√£o condicional
        return cached.path, cached.result
    end
    
    local path, result = findPathSmart(start, goal)
    pathCache[key] = {
        path = path,
        result = result,
        time = g_clock.millis()
    }
    
    return path, result
end
```

O sistema de mundo e mapas do OTClient oferece funcionalidade completa para jogos 2D isom√©tricos com performance otimizada e flexibilidade m√°xima para customiza√ß√£o.
## üîó **Links Autom√°ticos**

> [!info] **Links Gerados Automaticamente**
> Estes links foram criados automaticamente pelo sistema de linkagem da categoria **Legacy**

### **üìö Links Obrigat√≥rios**
- [[../README|Hub Central da Wiki]]
- [[../dashboard/task_master|Task Master]]
- [[../dashboard/integrated_task_manager|Dashboard Central]]
- [[../maps/search_index|Busca em Arquivos Legados]]
- [[../legacy_docs/README|Documenta√ß√£o Legada]]

### **üß≠ Navega√ß√£o**
- [[../maps/search_index|√çndice de Busca]]
- [[../maps/tags_index|√çndice de Tags]]
- [[../maps/category_indices|√çndices por Categoria]]
- [[../maps/relationships|Relacionamentos]]

### **üìä M√©tricas da Categoria**
- **Categoria**: Legacy
- **Total de arquivos**: <!-- Contador autom√°tico -->
- **Arquivos linkados**: <!-- Contador autom√°tico -->
- **Taxa de linkagem**: <!-- Percentual autom√°tico -->

---

