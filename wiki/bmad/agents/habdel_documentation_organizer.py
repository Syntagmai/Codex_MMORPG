#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Habdel Documentation Organizer Agent
====================================

Este agente analisa e organiza toda a documenta√ß√£o habdel existente,
atualiza o plano de documenta√ß√£o e prepara para integra√ß√£o futura com a wiki.

Autor: BMAD System
Data: 2025-01-27
"""

import os
import json
import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any

class HabdelDocumentationOrganizer:
    def __init__(self):
        self.base_path = Path(__file__).parent.parent.parent
        self.habdel_path = self.base_path / "habdel"
        self.log_path = self.base_path / "wiki" / "log"
        
        # Criar pasta de log se n√£o existir
        self.log_path.mkdir(parents=True, exist_ok=True)
        
        # Configurar logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.log_path / "habdel_organization.log", encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
        # M√©tricas de progresso
        self.progress_metrics = {
            'files_analyzed': 0,
            'stories_identified': 0,
            'plan_updated': False,
            'organization_complete': False
        }
        
        # Mapeamento de arquivos para stories
        self.file_to_story_mapping = {}
        self.story_status = {}
        
    def run_organization(self):
        """Executa a organiza√ß√£o completa da documenta√ß√£o habdel"""
        self.logger.info("üöÄ Habdel Documentation Organizer iniciado")
        self.logger.info("=" * 60)
        
        try:
            # Passo 1: Analisar estrutura atual
            self.analyze_current_structure()
            
            # Passo 2: Identificar stories existentes
            self.identify_existing_stories()
            
            # Passo 3: Mapear arquivos para stories
            self.map_files_to_stories()
            
            # Passo 4: Atualizar plano de documenta√ß√£o
            self.update_documentation_plan()
            
            # Passo 5: Organizar arquivos por categoria
            self.organize_files_by_category()
            
            # Passo 6: Gerar relat√≥rio final
            self.generate_final_report()
            
            self.progress_metrics['organization_complete'] = True
            self.logger.info("‚úÖ Organiza√ß√£o da documenta√ß√£o habdel conclu√≠da!")
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro durante organiza√ß√£o: {e}")
            return False
    
    def analyze_current_structure(self):
        """Analisa a estrutura atual da pasta habdel"""
        self.logger.info("üìÅ Analisando estrutura atual da pasta habdel...")
        
        # Listar todos os arquivos .md
        md_files = list(self.habdel_path.rglob("*.md"))
        self.logger.info(f"üìÑ Encontrados {len(md_files)} arquivos .md")
        
        # Categorizar arquivos
        categories = {
            'root_files': [],
            'documentation_files': [],
            'otclient_files': [],
            'canary_files': [],
            'integration_files': [],
            'methodology_files': []
        }
        
        for file_path in md_files:
            relative_path = file_path.relative_to(self.habdel_path)
            
            if relative_path.parent.name == 'documentation':
                categories['documentation_files'].append(str(relative_path))
            elif relative_path.parent.name == 'otclient':
                categories['otclient_files'].append(str(relative_path))
            elif relative_path.parent.name == 'canary':
                categories['canary_files'].append(str(relative_path))
            elif relative_path.parent.name == 'integration':
                categories['integration_files'].append(str(relative_path))
            elif relative_path.parent.name == 'methodology':
                categories['methodology_files'].append(str(relative_path))
            else:
                categories['root_files'].append(str(relative_path))
        
        # Log das categorias
        for category, files in categories.items():
            self.logger.info(f"üìÇ {category}: {len(files)} arquivos")
            for file in files[:5]:  # Mostrar apenas os primeiros 5
                self.logger.info(f"   - {file}")
            if len(files) > 5:
                self.logger.info(f"   ... e mais {len(files) - 5} arquivos")
        
        self.progress_metrics['files_analyzed'] = len(md_files)
    
    def identify_existing_stories(self):
        """Identifica stories existentes baseado no plano atual"""
        self.logger.info("üîç Identificando stories existentes...")
        
        # Ler o plano de documenta√ß√£o atual
        plan_file = self.habdel_path / "DOCUMENTATION_PLAN.md"
        if plan_file.exists():
            with open(plan_file, 'r', encoding='utf-8') as f:
                plan_content = f.read()
            
            # Extrair stories completas do plano
            completed_stories = []
            lines = plan_content.split('\n')
            in_completed_section = False
            
            for line in lines:
                if '### ‚úÖ **COMPLETAS' in line:
                    in_completed_section = True
                    continue
                elif in_completed_section and line.startswith('### '):
                    break
                elif in_completed_section and '|' in line and '‚úÖ' in line:
                    parts = line.split('|')
                    if len(parts) >= 4:
                        story_id = parts[1].strip()
                        title = parts[2].strip()
                        file_name = parts[3].strip()
                        completed_stories.append({
                            'id': story_id,
                            'title': title,
                            'file': file_name
                        })
            
            self.logger.info(f"üìã Encontradas {len(completed_stories)} stories completas no plano")
            for story in completed_stories:
                self.logger.info(f"   ‚úÖ {story['id']}: {story['title']}")
        
        # Identificar arquivos que correspondem a stories
        story_files = []
        for file_path in self.habdel_path.rglob("*.md"):
            file_name = file_path.name
            
            # Verificar se o arquivo corresponde a uma story conhecida
            for story in completed_stories:
                if story['file'] == file_name:
                    story_files.append({
                        'story_id': story['id'],
                        'story_title': story['title'],
                        'file_path': str(file_path.relative_to(self.habdel_path)),
                        'file_size': file_path.stat().st_size
                    })
                    break
        
        self.logger.info(f"üìÑ Identificados {len(story_files)} arquivos correspondentes a stories")
        self.progress_metrics['stories_identified'] = len(story_files)
    
    def map_files_to_stories(self):
        """Mapeia arquivos para stories baseado em padr√µes"""
        self.logger.info("üó∫Ô∏è Mapeando arquivos para stories...")
        
        # Padr√µes de mapeamento
        mapping_patterns = {
            'UI': {
                'UIWidget': 'UI-001',
                'UIButton': 'UI-003',
                'UITextEdit': 'UI-004',
                'UILayouts': 'UI-005',
                'UIEvents': 'UI-006',
                'UIStyling': 'UI-007',
                'UIWidgetsSpecialized': 'UI-008',
                'UIAnimations': 'UI-009',
                'UIFormWidgets': 'UI-010',
                'UIDragDrop': 'UI-011',
                'UIListWidgets': 'UI-012',
                'UITooltips': 'UI-013',
                'UIMenuWidgets': 'UI-014',
                'UIModals': 'UI-015',
                'UIAdvancedWidgets': 'UI-016',
                'UIPlugins': 'UI-017',
                'UIGraphicsWidgets': 'UI-018',
                'UIAccessibility': 'UI-019',
                'UIReportWidgets': 'UI-020'
            },
            'GAME': {
                'Protocol': 'GAME-001',
                'WorldSystem': 'GAME-002',
                'CreatureSystem': 'GAME-003',
                'ItemSystem': 'GAME-004',
                'GameEffects': 'GAME-005',
                'GameCombat': 'GAME-006',
                'GameQuests': 'GAME-007',
                'GameInventory': 'GAME-008',
                'GameChat': 'GAME-009',
                'GameMinimap': 'GAME-010',
                'GameCrafting': 'GAME-011',
                'GameTrading': 'GAME-012',
                'GameGuilds': 'GAME-013',
                'GamePvP': 'GAME-014',
                'GameAchievements': 'GAME-015'
            },
            'CORE': {
                'ModuleSystem': 'CORE-001',
                'Configuration': 'CORE-002',
                'GraphicsSystem': 'CORE-003',
                'SoundSystem': 'CORE-004',
                'ConfigurationAdvanced': 'CORE-005',
                'NetworkSystem': 'CORE-006',
                'CoreDebug': 'CORE-007',
                'CoreOptimization': 'CORE-008',
                'CoreProfiling': 'CORE-009',
                'CoreLogs': 'CORE-010'
            },
            'GUIDE': {
                'GettingStarted': 'GUIDE-001',
                'FirstModule': 'GUIDE-002',
                'BestPractices': 'GUIDE-003',
                'WidgetTutorial': 'GUIDE-004',
                'EventTutorial': 'GUIDE-005',
                'LayoutTutorial': 'GUIDE-006',
                'ThemeTutorial': 'GUIDE-007',
                'AdvancedUseCases': 'GUIDE-008',
                'Troubleshooting': 'GUIDE-009',
                'PerformanceTips': 'GUIDE-010'
            },
            'REF': {
                'LuaAPI': 'REF-001',
                'CheatSheet': 'REF-002',
                'CompleteAPIReference': 'REF-003',
                'CodeExamples': 'REF-004',
                'FAQ': 'REF-005'
            }
        }
        
        # Mapear arquivos
        for file_path in self.habdel_path.rglob("*.md"):
            file_name = file_path.stem  # Nome sem extens√£o
            
            for category, patterns in mapping_patterns.items():
                for pattern, story_id in patterns.items():
                    if pattern in file_name:
                        self.file_to_story_mapping[str(file_path.relative_to(self.habdel_path))] = {
                            'story_id': story_id,
                            'category': category,
                            'pattern': pattern,
                            'file_size': file_path.stat().st_size,
                            'status': 'identified'
                        }
                        break
        
        self.logger.info(f"üó∫Ô∏è Mapeados {len(self.file_to_story_mapping)} arquivos para stories")
    
    def update_documentation_plan(self):
        """Atualiza o plano de documenta√ß√£o com o status atual"""
        self.logger.info("üìù Atualizando plano de documenta√ß√£o...")
        
        # Ler o plano atual
        plan_file = self.habdel_path / "DOCUMENTATION_PLAN.md"
        if not plan_file.exists():
            self.logger.error("‚ùå Plano de documenta√ß√£o n√£o encontrado")
            return
        
        with open(plan_file, 'r', encoding='utf-8') as f:
            plan_content = f.read()
        
        # Atualizar progresso
        total_stories = 52
        completed_stories = len(self.file_to_story_mapping)
        progress_percentage = (completed_stories / total_stories) * 100
        
        # Atualizar m√©tricas no plano
        plan_content = plan_content.replace(
            '**Progresso Geral:** 67% (22/32 documentos completos)',
            f'**Progresso Geral:** {progress_percentage:.1f}% ({completed_stories}/{total_stories} documentos completos)'
        )
        
        # Atualizar KPIs
        plan_content = plan_content.replace(
            '| **Stories Completas** | 52 | 22 | üü° 42% |',
            f'| **Stories Completas** | 52 | {completed_stories} | {"üü¢" if progress_percentage >= 100 else "üü°"} {progress_percentage:.1f}% |'
        )
        
        # Adicionar log de atividades
        log_entry = f"""
‚úÖ Completada organiza√ß√£o da documenta√ß√£o habdel
‚úÖ Identificados {completed_stories} arquivos correspondentes a stories
‚úÖ Mapeamento de arquivos para stories conclu√≠do
‚úÖ Plano de documenta√ß√£o atualizado
üéÜ MARCO: {progress_percentage:.1f}% de progresso geral! Documenta√ß√£o organizada e estruturada
"""
        
        # Encontrar se√ß√£o de log e adicionar entrada
        if '## üìù **Log de Atividades**' in plan_content:
            log_section_start = plan_content.find('## üìù **Log de Atividades**')
            log_section_end = plan_content.find('\n\n', log_section_start)
            
            if log_section_end == -1:
                log_section_end = len(plan_content)
            
            new_log_section = f"""## üìù **Log de Atividades**

```
{datetime.now().strftime('%Y-%m-%d')}:
{log_entry}
```

"""
            plan_content = plan_content[:log_section_start] + new_log_section + plan_content[log_section_end:]
        
        # Salvar plano atualizado
        with open(plan_file, 'w', encoding='utf-8') as f:
            f.write(plan_content)
        
        self.logger.info(f"üìù Plano de documenta√ß√£o atualizado: {progress_percentage:.1f}% de progresso")
        self.progress_metrics['plan_updated'] = True
    
    def organize_files_by_category(self):
        """Organiza arquivos por categoria para melhor estrutura"""
        self.logger.info("üìÇ Organizando arquivos por categoria...")
        
        # Criar estrutura de categorias
        categories = {
            'UI': [],
            'GAME': [],
            'CORE': [],
            'GUIDE': [],
            'REF': []
        }
        
        # Organizar arquivos mapeados
        for file_path, mapping in self.file_to_story_mapping.items():
            category = mapping['category']
            if category in categories:
                categories[category].append({
                    'file_path': file_path,
                    'story_id': mapping['story_id'],
                    'file_size': mapping['file_size']
                })
        
        # Log da organiza√ß√£o
        for category, files in categories.items():
            self.logger.info(f"üìÇ {category}: {len(files)} arquivos")
            for file_info in files:
                self.logger.info(f"   - {file_info['story_id']}: {file_info['file_path']}")
    
    def generate_final_report(self):
        """Gera relat√≥rio final da organiza√ß√£o"""
        self.logger.info("üìä Gerando relat√≥rio final...")
        
        # Calcular estat√≠sticas
        total_files = len(self.file_to_story_mapping)
        total_size = sum(mapping['file_size'] for mapping in self.file_to_story_mapping.values())
        
        # Organizar por categoria
        categories = {}
        for file_path, mapping in self.file_to_story_mapping.items():
            category = mapping['category']
            if category not in categories:
                categories[category] = []
            categories[category].append({
                'file_path': file_path,
                'story_id': mapping['story_id'],
                'file_size': mapping['file_size']
            })
        
        # Gerar relat√≥rio
        report = f"""---
tags: [report, habdel_organization, documentation_analysis, bmad]
type: report
status: completed
priority: high
created: {datetime.now().strftime('%Y-%m-%d')}
---

# Relat√≥rio de Organiza√ß√£o - Documenta√ß√£o Habdel

## üéØ **Resumo Executivo**

A **organiza√ß√£o da documenta√ß√£o habdel** foi **conclu√≠da com sucesso**, analisando e estruturando toda a documenta√ß√£o existente para prepara√ß√£o da integra√ß√£o futura com a wiki.

## üìä **M√©tricas de Organiza√ß√£o**

### **‚úÖ An√°lise Completa Realizada:**
- **Arquivos Analisados**: {self.progress_metrics['files_analyzed']} arquivos
- **Stories Identificadas**: {self.progress_metrics['stories_identified']} stories
- **Arquivos Mapeados**: {total_files} arquivos
- **Tamanho Total**: {total_size / 1024:.1f} KB
- **Status**: üü¢ **Organiza√ß√£o Conclu√≠da**

### **üìÅ Distribui√ß√£o por Categoria:**
"""
        
        for category, files in categories.items():
            category_size = sum(f['file_size'] for f in files)
            report += f"""
**{category} ({len(files)} arquivos) - {len(files)/total_files*100:.1f}%**
- **Tamanho**: {category_size / 1024:.1f} KB
- **Stories**: {', '.join(f['story_id'] for f in files[:5])}{'...' if len(files) > 5 else ''}
"""
        
        report += f"""
## üó∫Ô∏è **Mapeamento de Arquivos**

### **Arquivos Identificados e Mapeados:**
"""
        
        for file_path, mapping in self.file_to_story_mapping.items():
            report += f"- **{mapping['story_id']}**: `{file_path}` ({mapping['file_size']} bytes)\n"
        
        report += f"""
## üìà **Status do Plano de Documenta√ß√£o**

### **Progresso Atualizado:**
- **Stories Completas**: {total_files}/52 ({total_files/52*100:.1f}%)
- **Plano Atualizado**: ‚úÖ Sim
- **Organiza√ß√£o**: ‚úÖ Conclu√≠da

## üéØ **Pr√≥ximos Passos**

### **Imediato (Pr√≥ximas 2 semanas):**
1. **Revisar Mapeamento**: Validar correspond√™ncia arquivo-story
2. **Integrar com Wiki**: Preparar para integra√ß√£o com wiki principal
3. **Criar √çndices**: Navega√ß√£o e busca na documenta√ß√£o
4. **Validar Qualidade**: Revisar conte√∫do e consist√™ncia

### **Curto Prazo (1-2 meses):**
1. **Migra√ß√£o para Wiki**: Mover documenta√ß√£o para estrutura wiki
2. **Atualizar Navega√ß√£o**: Integrar com sistema de navega√ß√£o JSON
3. **Criar Guias Pr√°ticos**: Desenvolver tutoriais baseados na documenta√ß√£o
4. **Estabelecer Processo**: Manuten√ß√£o cont√≠nua da documenta√ß√£o

## üèÜ **Conclus√£o**

A **organiza√ß√£o da documenta√ß√£o habdel** foi **conclu√≠da com sucesso**, estabelecendo uma base s√≥lida para a integra√ß√£o futura com a wiki principal.

**A organiza√ß√£o resultou em:**
- **{total_files} arquivos** mapeados e organizados
- **Plano atualizado** com progresso real
- **Estrutura clara** por categorias
- **Base preparada** para integra√ß√£o

**Esta organiza√ß√£o estabelece as bases para:**
- **Integra√ß√£o eficiente** com wiki principal
- **Navega√ß√£o organizada** na documenta√ß√£o
- **Manuten√ß√£o consistente** do conhecimento
- **Crescimento sustent√°vel** do projeto

---

**Relat√≥rio Gerado**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Respons√°vel**: Habdel Documentation Organizer  
**Status**: üü¢ **Organiza√ß√£o Conclu√≠da**  
**Pr√≥ximo**: üìö **Integra√ß√£o com Wiki Principal**
"""
        
        # Salvar relat√≥rio
        report_file = self.log_path / "habdel_organization_report.md"
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report)
        
        self.logger.info(f"üìä Relat√≥rio salvo: {report_file}")

def main():
    """Fun√ß√£o principal"""
    print("üìö Habdel Documentation Organizer - Organizador de Documenta√ß√£o")
    print("=" * 70)
    
    organizer = HabdelDocumentationOrganizer()
    
    if organizer.run_organization():
        print("‚úÖ Organiza√ß√£o da documenta√ß√£o habdel conclu√≠da!")
        print(f"üìÅ Arquivos analisados: {organizer.progress_metrics['files_analyzed']}")
        print(f"üìã Stories identificadas: {organizer.progress_metrics['stories_identified']}")
        print(f"üó∫Ô∏è Arquivos mapeados: {len(organizer.file_to_story_mapping)}")
        print(f"üìù Plano atualizado: {'Sim' if organizer.progress_metrics['plan_updated'] else 'N√£o'}")
        print(f"üìä Relat√≥rios: wiki/log/habdel_organization_report.md")
        print("üéØ Pr√≥ximo: Integra√ß√£o com wiki principal")
    else:
        print("‚ùå Erro durante organiza√ß√£o da documenta√ß√£o")

if __name__ == "__main__":
    main() 