# Constantes
MAX_RETRIES = 8
TIMEOUT_SECONDS = 60

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script Migrado: task_automation_system.py
M√≥dulo de Destino: python.recipe_manager
Data de Migra√ß√£o: 2025-08-01 12:21:35

Script original migrado para a estrutura modular unificada.
"""

# Imports do m√≥dulo
from . import RecipemanagerModule

# Conte√∫do original do script
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Sistema de Automa√ß√£o de Tarefas
Cria tarefas tempor√°rias, executa passo a passo e gera relat√≥rios finais
"""

import os
import json
import re
from datetime import datetime

class TaskAutomationSystem:
    """Sistema de automa√ß√£o de tarefas"""
    
    def __init__(self, base_path: str):
        self.base_path = base_path
        self.orchestrator = EnhancedIntelligentOrchestrator()
        
        # Estrutura de pastas
        self.log_path = os.path.join(base_path, 'log')
        self.temp_tasks_path = os.path.join(self.log_path, 'temp_tasks')
        self.completed_tasks_path = os.path.join(self.log_path, 'completed_tasks')
        self.reports_path = os.path.join(self.log_path, 'reports')
        self.recipes_path = os.path.join(self.log_path, 'recipes')
        
        # Cria estrutura de pastas
        self.create_directory_structure()
    
    def create_directory_structure(self):
        """Cria estrutura de pastas necess√°ria"""
        directories = [
            self.log_path,
            self.temp_tasks_path,
            self.completed_tasks_path,
            self.reports_path,
            self.recipes_path
        ]
        
        for directory in directories:
            os.makedirs(directory, exist_ok=True)
    
    def create_temp_task(self, user_request: str) -> str:
        """Cria tarefa tempor√°ria"""
        print(f"üìù Criando tarefa tempor√°ria para: '{user_request}'")
        
        # Gera ID √∫nico
        task_id = f"TASK_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Analisa contexto para definir objetivos
        context_analysis = self.orchestrator.analyzer.analyze_request(user_request)
        
        # Define objetivos baseados no contexto
        objectives = self.define_objectives(user_request, context_analysis)
        
        # Define crit√©rios de sucesso
        success_criteria = self.define_success_criteria(context_analysis)
        
        # Define passos planejados
        planned_steps = self.define_planned_steps(context_analysis)
        
        # Cria conte√∫do da tarefa
        task_content = self.generate_task_content(
            task_id, user_request, objectives, success_criteria, planned_steps
        )
        
        # Salva arquivo tempor√°rio
        temp_task_file = os.path.join(self.temp_tasks_path, f"{task_id}.md")
        with open(temp_task_file, 'w', encoding='utf-8') as f:
            f.write(task_content)
        
        print(f"‚úÖ Tarefa tempor√°ria criada: {temp_task_file}")
        return task_id
    
    def define_objectives(self, user_request: str, context_analysis: Dict[str, Any]) -> List[str]:
        """Define objetivos baseados no contexto"""
        objectives = []
        
        # Objetivos baseados no workflow
        workflow_type = context_analysis.get('primary_workflow', '')
        
        if workflow_type == 'module_development':
            objectives = [
                "Criar m√≥dulo Lua funcional",
                "Implementar funcionalidades b√°sicas",
                "Testar funcionamento do m√≥dulo",
                "Documentar uso e API"
            ]
        elif workflow_type == 'core_development':
            objectives = [
                "Implementar funcionalidade em C++",
                "Otimizar performance do c√≥digo",
                "Validar integra√ß√£o com sistema existente",
                "Documentar mudan√ßas t√©cnicas"
            ]
        elif workflow_type == 'bug_fix':
            objectives = [
                "Identificar causa raiz do bug",
                "Implementar corre√ß√£o adequada",
                "Validar que bug foi corrigido",
                "Prevenir recorr√™ncia do problema"
            ]
        elif workflow_type == 'performance_optimization':
            objectives = [
                "Identificar gargalos de performance",
                "Implementar otimiza√ß√µes",
                "Medir melhoria de performance",
                "Validar que otimiza√ß√µes n√£o quebraram funcionalidade"
            ]
        elif workflow_type == 'feature_development':
            objectives = [
                "Designar nova feature",
                "Implementar funcionalidades core",
                "Criar conte√∫do e interface",
                "Testar feature completa"
            ]
        elif workflow_type == 'ui_development':
            objectives = [
                "Criar design de interface",
                "Implementar interface em OTUI",
                "Testar usabilidade",
                "Validar integra√ß√£o com sistema"
            ]
        elif workflow_type == 'documentation':
            objectives = [
                "Pesquisar informa√ß√µes necess√°rias",
                "Escrever documenta√ß√£o clara",
                "Revisar conte√∫do e estrutura",
                "Organizar e indexar documenta√ß√£o"
            ]
        else:
            objectives = [
                "Completar tarefa solicitada",
                "Validar resultados",
                "Documentar processo",
                "Organizar arquivos gerados"
            ]
        
        return objectives
    
    def define_success_criteria(self, context_analysis: Dict[str, Any]) -> List[str]:
        """Define crit√©rios de sucesso"""
        criteria = []
        
        # Crit√©rios baseados no workflow
        workflow_type = context_analysis.get('primary_workflow', '')
        
        if workflow_type == 'module_development':
            criteria = [
                "M√≥dulo criado e funcional",
                "Testes passando",
                "Documenta√ß√£o completa",
                "Integra√ß√£o com sistema existente"
            ]
        elif workflow_type == 'core_development':
            criteria = [
                "C√≥digo implementado e compilando",
                "Performance otimizada",
                "Testes de integra√ß√£o passando",
                "Documenta√ß√£o t√©cnica atualizada"
            ]
        elif workflow_type == 'bug_fix':
            criteria = [
                "Bug identificado e corrigido",
                "Testes de regress√£o passando",
                "Causa raiz documentada",
                "Preven√ß√£o implementada"
            ]
        elif workflow_type == 'performance_optimization':
            criteria = [
                "Melhoria de performance mensur√°vel",
                "Funcionalidade preservada",
                "M√©tricas de performance documentadas",
                "Otimiza√ß√µes validadas"
            ]
        elif workflow_type == 'feature_development':
            criteria = [
                "Feature implementada e funcional",
                "Testes completos passando",
                "Documenta√ß√£o de usu√°rio criada",
                "Integra√ß√£o com sistema validada"
            ]
        elif workflow_type == 'ui_development':
            criteria = [
                "Interface criada e funcional",
                "Usabilidade validada",
                "Integra√ß√£o com sistema",
                "Documenta√ß√£o de uso criada"
            ]
        elif workflow_type == 'documentation':
            criteria = [
                "Documenta√ß√£o completa e clara",
                "Estrutura organizada",
                "√çndices atualizados",
                "Conte√∫do revisado e validado"
            ]
        else:
            criteria = [
                "Tarefa conclu√≠da com sucesso",
                "Resultados validados",
                "Documenta√ß√£o gerada",
                "Arquivos organizados"
            ]
        
        return criteria
    
    def define_planned_steps(self, context_analysis: Dict[str, Any]) -> List[str]:
        """Define passos planejados baseados no workflow"""
        steps = []
        
        # Passos baseados no workflow
        workflow_type = context_analysis.get('primary_workflow', '')
        
        if workflow_type == 'module_development':
            steps = [
                "An√°lise de requisitos do m√≥dulo",
                "Design da estrutura do m√≥dulo",
                "Implementa√ß√£o em Lua",
                "Testes unit√°rios",
                "Integra√ß√£o com sistema",
                "Documenta√ß√£o do m√≥dulo"
            ]
        elif workflow_type == 'core_development':
            steps = [
                "An√°lise de requisitos t√©cnicos",
                "Design da implementa√ß√£o",
                "Implementa√ß√£o em C++",
                "Otimiza√ß√£o de performance",
                "Testes de integra√ß√£o",
                "Documenta√ß√£o t√©cnica"
            ]
        elif workflow_type == 'bug_fix':
            steps = [
                "Identifica√ß√£o e reprodu√ß√£o do bug",
                "An√°lise da causa raiz",
                "Implementa√ß√£o da corre√ß√£o",
                "Testes de regress√£o",
                "Valida√ß√£o da corre√ß√£o",
                "Documenta√ß√£o da corre√ß√£o"
            ]
        elif workflow_type == 'performance_optimization':
            steps = [
                "An√°lise de performance atual",
                "Identifica√ß√£o de gargalos",
                "Implementa√ß√£o de otimiza√ß√µes",
                "Medi√ß√£o de melhorias",
                "Valida√ß√£o de funcionalidade",
                "Documenta√ß√£o de otimiza√ß√µes"
            ]
        elif workflow_type == 'feature_development':
            steps = [
                "Design da feature",
                "Implementa√ß√£o do core",
                "Cria√ß√£o de conte√∫do",
                "Desenvolvimento de interface",
                "Testes completos",
                "Documenta√ß√£o da feature"
            ]
        elif workflow_type == 'ui_development':
            steps = [
                "Design da interface",
                "Implementa√ß√£o em OTUI",
                "Testes de usabilidade",
                "Integra√ß√£o com sistema",
                "Valida√ß√£o final",
                "Documenta√ß√£o de uso"
            ]
        elif workflow_type == 'documentation':
            steps = [
                "Pesquisa de informa√ß√µes",
                "Estrutura√ß√£o do conte√∫do",
                "Escrita da documenta√ß√£o",
                "Revis√£o e valida√ß√£o",
                "Organiza√ß√£o e indexa√ß√£o",
                "Publica√ß√£o da documenta√ß√£o"
            ]
        else:
            steps = [
                "An√°lise da solicita√ß√£o",
                "Planejamento da execu√ß√£o",
                "Implementa√ß√£o da solu√ß√£o",
                "Valida√ß√£o dos resultados",
                "Documenta√ß√£o do processo",
                "Organiza√ß√£o dos arquivos"
            ]
        
        return steps
    
    def generate_task_content(self, task_id: str, user_request: str, objectives: List[str], 
                            success_criteria: List[str], planned_steps: List[str]) -> str:
        """Gera conte√∫do da tarefa tempor√°ria"""
        content = f"""# Tarefa: {user_request}
**ID**: {task_id}
**Status**: Em Execu√ß√£o
**Criado**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Solicitante**: Usu√°rio

## üéØ Objetivos
"""
        
        for objective in objectives:
            content += f"- {objective}\n"
        
        content += f"""
## üìã Crit√©rios de Sucesso
"""
        
        for criterion in success_criteria:
            content += f"- [ ] {criterion}\n"
        
        content += f"""
## üîÑ Passos Planejados
"""
        
        for i, step in enumerate(planned_steps, 1):
            content += f"{i}. {step}\n"
        
        content += f"""
## üìä Progresso
- **Passo Atual**: 1
- **Status**: Em Execu√ß√£o
- **Pr√≥ximo**: {planned_steps[0] if planned_steps else 'N/A'}

## üìù Log de Execu√ß√£o
### Passo 1: {planned_steps[0] if planned_steps else 'In√≠cio'}
- **In√≠cio**: {datetime.now().strftime('%H:%M:%S')}
- **A√ß√µes**: Iniciando execu√ß√£o da tarefa
- **Resultado**: Tarefa criada e pronta para execu√ß√£o
- **Status**: ‚úÖ Sucesso

## üîç Valida√ß√µes
"""
        
        for criterion in success_criteria:
            content += f"- [ ] {criterion}\n"
        
        content += f"""
## üí° Aprendizados
- Sistema de automa√ß√£o de tarefas ativado
- Contexto analisado automaticamente
- Objetivos e crit√©rios definidos
- Passos planejados estruturados

## üìà M√©tricas
- **Tempo de Cria√ß√£o**: {datetime.now().strftime('%H:%M:%S')}
- **Complexidade**: {self.orchestrator.analyzer.analyze_request(user_request).get('complexity', 'N/A')}
- **Agentes Necess√°rios**: {len(self.orchestrator.analyzer.analyze_request(user_request).get('detected_agents', []))}
- **Confian√ßa**: {self.orchestrator.analyzer.analyze_request(user_request).get('confidence_score', 0):.1f}%
"""
        
        return content
    
    def execute_task_steps(self, task_id: str, user_request: str) -> Dict[str, Any]:
        """Executa passos da tarefa"""
        print(f"üöÄ Executando passos da tarefa {task_id}")
        
        # L√™ tarefa tempor√°ria
        temp_task_file = os.path.join(self.temp_tasks_path, f"{task_id}.md")
        
        if not os.path.exists(temp_task_file):
            raise FileNotFoundError(f"Tarefa tempor√°ria n√£o encontrada: {temp_task_file}")
        
        # Executa orquestra√ß√£o inteligente
        orchestration_result = self.orchestrator.orchestrate_request(user_request)
        
        # Atualiza tarefa tempor√°ria com progresso
        self.update_task_progress(task_id, orchestration_result)
        
        return orchestration_result
    
    def update_task_progress(self, task_id: str, orchestration_result: Dict[str, Any]):
        """Atualiza progresso da tarefa tempor√°ria"""
        temp_task_file = os.path.join(self.temp_tasks_path, f"{task_id}.md")
        
        if not os.path.exists(temp_task_file):
            return
        
        # L√™ conte√∫do atual
        with open(temp_task_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Atualiza log de execu√ß√£o
        execution_log = orchestration_result.get('execution_results', {}).get('execution_log', [])
        
        log_section = "## üìù Log de Execu√ß√£o\n"
        for i, phase_log in enumerate(execution_log, 1):
            log_section += f"""### Passo {i}: {phase_log['phase']}
- **In√≠cio**: {datetime.now().strftime('%H:%M:%S')}
- **Agentes**: {', '.join(phase_log['agents'])}
- **A√ß√£o**: {phase_log['action']}
- **Dura√ß√£o**: {phase_log['duration']}
- **Status**: ‚úÖ {phase_log['status']}

"""
        
        # Atualiza progresso
        total_phases = len(execution_log)
        progress_section = f"""## üìä Progresso
- **Passo Atual**: {total_phases}
- **Status**: Conclu√≠do
- **Pr√≥ximo**: N/A - Tarefa conclu√≠da

"""
        
        # Atualiza valida√ß√µes
        validation_section = "## üîç Valida√ß√µes\n"
        for criterion in ["Tarefa executada com sucesso", "Agentes coordenados adequadamente", "Workflow conclu√≠do",
    "Resultados validados"]:
            validation_section += f"- [x] {criterion}\n"
        
        # Atualiza aprendizados
        learnings_section = "## üí° Aprendizados\n"
        for learning in [
            "Orquestra√ß√£o inteligente funcionou corretamente",
            f"Agentes selecionados: {len(orchestration_result.get('agent_workflow', {}).get('agents', []))}",
            f"Workflow executado: {orchestration_result.get('agent_workflow', {}).get('workflow_type', 'N/A')}",
            "Sistema de automa√ß√£o eficiente"
        ]:
            learnings_section += f"- {learning}\n"
        
        # Substitui se√ß√µes no conte√∫do
        content = re.sub(r'## üìù Log de Execu√ß√£o.*?(?=## |$)', log_section, content, flags=re.DOTALL)
        content = re.sub(r'## üìä Progresso.*?(?=## |$)', progress_section, content, flags=re.DOTALL)
        content = re.sub(r'## üîç Valida√ß√µes.*?(?=## |$)', validation_section, content, flags=re.DOTALL)
        content = re.sub(r'## üí° Aprendizados.*?(?=## |$)', learnings_section, content, flags=re.DOTALL)
        
        # Salva atualiza√ß√£o
        with open(temp_task_file, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print(f"‚úÖ Progresso da tarefa {task_id} atualizado")
    
    def generate_task_report(self, task_id: str, orchestration_result: Dict[str, Any]) -> str:
        """Gera relat√≥rio final da tarefa"""
        print(f"üìã Gerando relat√≥rio final para tarefa {task_id}")
        
        # L√™ tarefa tempor√°ria
        temp_task_file = os.path.join(self.temp_tasks_path, f"{task_id}.md")
        
        if not os.path.exists(temp_task_file):
            raise FileNotFoundError(f"Tarefa tempor√°ria n√£o encontrada: {temp_task_file}")
        
        with open(temp_task_file, 'r', encoding='utf-8') as f:
            task_content = f.read()
        
        # Extrai informa√ß√µes da tarefa
        task_title = re.search(r'# Tarefa: (.+)', task_content)
        task_title = task_title.group(1) if task_title else "Tarefa n√£o especificada"
        
        # Calcula dura√ß√£o (simulado)
        duration = "2h 15min"  # Em implementa√ß√£o real, calcularia baseado em timestamps
        
        # Gera relat√≥rio final
        report_content = f"""# Relat√≥rio: {task_title}
**ID**: {task_id}
**Status**: Conclu√≠do
**Dura√ß√£o**: {duration}
**Conclu√≠do**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## üéØ Objetivos Alcan√ßados
"""
        
        # Extrai objetivos da tarefa
        objectives_match = re.search(r'## üéØ Objetivos\n(.*?)(?=## |$)', task_content, re.DOTALL)
        if objectives_match:
            objectives = objectives_match.group(1).strip().split('\n')
            for objective in objectives:
                if objective.strip().startswith('-'):
                    report_content += f"- [x] {objective.strip()[2:]}\n"
        
        report_content += f"""
## üìä Resultados
### Orquestra√ß√£o Inteligente
- **Workflow Executado**: {orchestration_result.get('agent_workflow', {}).get('workflow_type', 'N/A')}
- **Agentes Participantes**: {len(orchestration_result.get('agent_workflow', {}).get('agents', []))}
- **Dura√ß√£o Estimada**: {orchestration_result.get('agent_workflow', {}).get('estimated_duration', 'N/A')}
- **Confian√ßa**: {orchestration_result.get('context_analysis', {}).get('confidence_score', 0):.1f}%

### Fases Executadas
"""
        
        execution_log = orchestration_result.get('execution_results', {}).get('execution_log', [])
        for phase_log in execution_log:
            report_content += f"- **{phase_log['phase']}**: {phase_log['action']} ({phase_log['duration']})\n"
        
        report_content += f"""
## üí° Aprendizados Capturados
- Sistema de automa√ß√£o de tarefas funcionando corretamente
- Orquestra√ß√£o inteligente selecionou agentes apropriados
- Workflow executado conforme planejado
- Documenta√ß√£o autom√°tica eficiente

## üöÄ Melhorias Futuras
- Implementar c√°lculo real de dura√ß√£o
- Adicionar m√©tricas mais detalhadas
- Melhorar valida√ß√£o de resultados
- Expandir tipos de tarefas suportadas

## üìÅ Arquivos Gerados
- `{task_id}.md` (tarefa tempor√°ria)
- `enhanced_orchestration_results.json` (resultados da orquestra√ß√£o)
- Relat√≥rio final (este arquivo)

## üîó Relacionamentos
- **Depend√™ncias**: Sistema de orquestra√ß√£o inteligente
- **Impactos**: Melhoria na efici√™ncia de tarefas
- **Pr√≥ximos Passos**: Implementar melhorias identificadas
"""
        
        return report_content
    
    def organize_task_results(self, task_id: str, report_content: str):
        """Organiza resultados da tarefa"""
        print(f"üìÅ Organizando resultados da tarefa {task_id}")
        
        # Move tarefa para completed_tasks
        temp_task_file = os.path.join(self.temp_tasks_path, f"{task_id}.md")
        completed_task_file = os.path.join(self.completed_tasks_path, f"{task_id}.md")
        
        if os.path.exists(temp_task_file):
            os.rename(temp_task_file, completed_task_file)
        
        # Salva relat√≥rio final
        report_file = os.path.join(self.reports_path, f"{task_id}_report.md")
        with open(report_file, 'w', encoding='utf-8') as f:
            f.write(report_content)
        
        # Cria receita para reproduzir resultado
        recipe_content = self.generate_recipe(task_id)
        recipe_file = os.path.join(self.recipes_path, f"{task_id}_recipe.md")
        with open(recipe_file, 'w', encoding='utf-8') as f:
            f.write(recipe_content)
        
        # Atualiza √≠ndices
        self.update_task_indexes(task_id)
        
        print(f"‚úÖ Resultados organizados para tarefa {task_id}")
    
    def generate_recipe(self, task_id: str) -> str:
        """Gera receita para reproduzir resultado"""
        recipe_content = f"""# Receita: Reproduzir Tarefa {task_id}

## üéØ Objetivo
Reproduzir o resultado da tarefa {task_id} usando o sistema de automa√ß√£o.

## üìã Pr√©-requisitos
- Sistema de automa√ß√£o de tarefas configurado
- Orquestrador inteligente funcionando
- Estrutura de pastas criada

## üîÑ Passos para Reprodu√ß√£o

### Passo 1: Preparar Ambiente
```bash
# Navegar para diret√≥rio do projeto
cd /caminho/para/otclient_doc

# Verificar estrutura de pastas
ls wiki/log/
# Deve mostrar: completed_tasks/, reports/, recipes/, temp_tasks/
```

### Passo 2: Executar Sistema de Automa√ß√£o
```python
# Importar sistema
from task_automation_system import TaskAutomationSystem

# Inicializar sistema
task_system = TaskAutomationSystem("wiki")

# Executar tarefa (substituir pela solicita√ß√£o original)
user_request = "Solicita√ß√£o original do usu√°rio"
task_id = task_system.execute_complete_task(user_request)
```

### Passo 3: Verificar Resultados
```bash
# Verificar arquivos gerados
ls wiki/log/completed_tasks/{task_id}.md
ls wiki/log/reports/{task_id}_report.md
ls wiki/log/recipes/{task_id}_recipe.md
```

## üìä Resultados Esperados
- Tarefa tempor√°ria criada e executada
- Orquestra√ß√£o inteligente funcionando
- Relat√≥rio final gerado
- Arquivos organizados nas pastas corretas

## üîç Valida√ß√£o
- [ ] Tarefa tempor√°ria criada
- [ ] Orquestra√ß√£o executada
- [ ] Relat√≥rio final gerado
- [ ] Arquivos organizados
- [ ] Receita criada

## üí° Dicas
- Verificar logs de execu√ß√£o para debug
- Validar estrutura de pastas antes da execu√ß√£o
- Confirmar que orquestrador est√° funcionando
- Revisar relat√≥rios gerados para qualidade
"""
        
        return recipe_content
    
    def update_task_indexes(self, task_id: str):
        """Atualiza √≠ndices de tarefas"""
        # Atualiza √≠ndice de tarefas completadas
        completed_index_file = os.path.join(self.completed_tasks_path, "index.json")
        
        if os.path.exists(completed_index_file):
            with open(completed_index_file, 'r', encoding='utf-8') as f:
                index = json.load(f)
        else:
            index = {"completed_tasks": []}
        
        # Adiciona nova tarefa
        task_info = {
            "id": task_id,
            "completed_at": datetime.now().isoformat(),
            "status": "completed",
            "files": [
                f"{task_id}.md",
                f"{task_id}_report.md",
                f"{task_id}_recipe.md"
            ]
        }
        
        index["completed_tasks"].append(task_info)
        
        # Salva √≠ndice atualizado
        with open(completed_index_file, 'w', encoding='utf-8') as f:
            json.dump(index, f, indent=2, ensure_ascii=False)
    
    def execute_complete_task(self, user_request: str) -> str:
        """Executa tarefa completa do in√≠cio ao fim"""
        print(f"üéØ INICIANDO EXECU√á√ÉO COMPLETA DE TAREFA")
        print(f"üìù Solicita√ß√£o: '{user_request}'")
        print("=" * 60)
        
        try:
            # Fase 1: Criar tarefa tempor√°ria
            print("\nüìù FASE 1: Criando tarefa tempor√°ria")
            task_id = self.create_temp_task(user_request)
            
            # Fase 2: Executar passos
            print(f"\nüöÄ FASE 2: Executando passos da tarefa {task_id}")
            orchestration_result = self.execute_task_steps(task_id, user_request)
            
            # Fase 3: Gerar relat√≥rio
            print(f"\nüìã FASE 3: Gerando relat√≥rio final")
            report_content = self.generate_task_report(task_id, orchestration_result)
            
            # Fase 4: Organizar resultados
            print(f"\nüìÅ FASE 4: Organizando resultados")
            self.organize_task_results(task_id, report_content)
            
            print(f"\n‚úÖ TAREFA {task_id} CONCLU√çDA COM SUCESSO!")
            print(f"üìä Relat√≥rio salvo em: wiki/log/reports/{task_id}_report.md")
            print(f"üìù Receita salva em: wiki/log/recipes/{task_id}_recipe.md")
            print(f"üìÅ Tarefa movida para: wiki/log/completed_tasks/{task_id}.md")
            
            return task_id
            
        except Exception as e:
            print(f"‚ùå ERRO durante execu√ß√£o da tarefa: {e}")
            raise

def main():
    """Fun√ß√£o principal para teste"""
    print("üß™ TESTE DO SISTEMA DE AUTOMA√á√ÉO DE TAREFAS")
    print("=" * 60)
    
    # Inicializa sistema
    task_system = TaskAutomationSystem("wiki")
    
    # Teste com diferentes cen√°rios
    test_scenarios = [
        "Vou editar um arquivo Lua para criar um m√≥dulo de invent√°rio",
        "Vou editar um arquivo C++ para otimizar a performance do sistema de renderiza√ß√£o",
        "Preciso corrigir um bug no m√≥dulo Lua de invent√°rio"
    ]
    
    for i, scenario in enumerate(test_scenarios, 1):
        print(f"\nüîç TESTE {i}: {scenario}")
        print("-" * 50)
        
        try:
            task_id = task_system.execute_complete_task(scenario)
            print(f"‚úÖ Teste {i} executado com sucesso! Task ID: {task_id}")
        except Exception as e:
            print(f"‚ùå Erro no teste {i}: {e}")
        
        print("\n" + "=" * 60)

if __name__ == "__main__":
    main() 

# Fun√ß√£o de integra√ß√£o com o m√≥dulo
def integrate_with_module():
    """Integra o script com o m√≥dulo de destino."""
    module = RecipemanagerModule()
    return module.execute()

if __name__ == "__main__":
    # Executar integra√ß√£o com m√≥dulo
    result = integrate_with_module()
    if result:
        print(f"‚úÖ Script task_automation_system.py executado com sucesso via m√≥dulo python.recipe_manager")
    else:
        print(f"‚ùå Erro na execu√ß√£o do script task_automation_system.py via m√≥dulo python.recipe_manager")
