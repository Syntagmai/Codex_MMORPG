#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script Migrado: intelligent_organization_agent.py
M√≥dulo de Destino: agents.agent_orchestrator
Data de Migra√ß√£o: 2025-08-01 12:21:43

Script original migrado para a estrutura modular unificada.
"""

# Imports do m√≥dulo
from . import AgentorchestratorModule

# Conte√∫do original do script
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Agente de Organiza√ß√£o Inteligente - Sistema de Code Cleanup e Integra√ß√£o Canary
===============================================================================

Agente especializado em organiza√ß√£o autom√°tica de arquivos, pastas e relat√≥rios
baseado nas regras de code cleanup. Mant√©m o sistema sempre limpo e organizado.
Inclui suporte para integra√ß√£o total com Canary.

Autor: Sistema BMAD - OTClient Documentation
Data: 2025-01-27
Vers√£o: 1.1 - Suporte Canary
"""

import os
import json
import shutil
import re
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
import logging

# Configura√ß√£o de logging
log_dir = Path.cwd() / 'wiki' / 'log'
log_dir.mkdir(parents=True, exist_ok=True)
log_file = log_dir / 'intelligent_organization.log'

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file, encoding='utf-8'),
        logging.StreamHandler()
    ]
)

class IntelligentOrganizationAgent:
    """Agente de organiza√ß√£o inteligente para code cleanup e integra√ß√£o Canary"""
    
    def __init__(self, base_path: str = "."):
        self.base_path = Path(base_path)
        self.logger = logging.getLogger(__name__)
        
        # Estrutura de pastas
        self.wiki_path = self.base_path / "wiki"
        self.log_path = self.wiki_path / "log"
        self.update_path = self.wiki_path / "update"
        self.canary_path = self.wiki_path / "canary"
        self.maps_path = self.wiki_path / "maps"
        
        # Padr√µes de detec√ß√£o (incluindo Canary)
        self.patterns = {
            "report": ["*_REPORT.md", "*_report.md", "Relat√≥rio_*.md", "RELATORIO_*.md"],
            "task": ["TASK_*.md", "*_task.md", "*_TASK.md"],
            "recipe": ["*_RECIPE.md", "*_recipe.md"],
            "log": ["*.log", "*_log.md", "*_LOG.md"],
            "config": ["*.json", "*.yaml", "*.yml"],
            "script": ["*.py", "*.sh", "*.bat"],
            "temp": ["*_temp.md", "*_tmp.md", "temp_*", "tmp_*", "*_backup.md", "*_old.md"],
            "obsolete": ["*_obsolete.md", "*_archive.md", "*_deprecated.md"],
            "canary": ["*_canary.md", "*_CANARY.md", "canary_*", "CANARY_*"],
            "integration": ["*_integration.md", "*_INTEGRATION.md", "integration_*", "INTEGRATION_*"],
            "template": ["*_template.md", "*_TEMPLATE.md", "template_*", "TEMPLATE_*"]
        }
        
        # Categorias de organiza√ß√£o (incluindo Canary)
        self.categories = {
            "reports": {
                "patterns": self.patterns["report"],
                "destination": self.log_path / "reports" / "current",
                "archive_destination": self.log_path / "reports"
            },
            "completed_tasks": {
                "patterns": self.patterns["task"],
                "destination": self.log_path / "completed_tasks",
                "archive_destination": self.log_path / "archives" / "completed_tasks"
            },
            "recipes": {
                "patterns": self.patterns["recipe"],
                "destination": self.log_path / "recipes",
                "archive_destination": self.log_path / "archives" / "recipes"
            },
            "archives": {
                "patterns": self.patterns["obsolete"],
                "destination": self.log_path / "archives" / "obsolete_files",
                "archive_destination": self.log_path / "archives" / "obsolete_files"
            },
            "canary_integration": {
                "patterns": self.patterns["canary"] + self.patterns["integration"],
                "destination": self.canary_path / "integration",
                "archive_destination": self.canary_path / "archives"
            },
            "canary_templates": {
                "patterns": self.patterns["template"],
                "destination": self.canary_path / "templates",
                "archive_destination": self.canary_path / "archives" / "templates"
            },
            "integration_maps": {
                "patterns": ["*_integration_map.json", "*_canary_map.json"],
                "destination": self.maps_path / "integration",
                "archive_destination": self.maps_path / "archives"
            }
        }
        
        # Configura√ß√µes de integra√ß√£o Canary
        self.canary_config = {
            "integration_phases": [
                "preparation",
                "structure_validation", 
                "template_creation",
                "workflow_setup",
                "testing",
                "final_integration"
            ],
            "compatibility_checks": [
                "file_structure",
                "api_interfaces",
                "documentation_format",
                "code_standards",
                "dependencies"
            ],
            "integration_points": [
                "src/",
                "modules/",
                "data/",
                "wiki/",
                "docs/"
            ]
        }
        
        self.logger.info("ü§ñ Agente de Organiza√ß√£o Inteligente com suporte Canary inicializado")
    
    def detect_organization_issues(self) -> Dict[str, List[Path]]:
        """
        Detecta problemas de organiza√ß√£o automaticamente.
        Inclui detec√ß√£o espec√≠fica para arquivos de integra√ß√£o Canary.
        
        Returns:
            Dicion√°rio com problemas encontrados
        """
        self.logger.info("üîç Detectando problemas de organiza√ß√£o...")
        
        issues = {
            "files_in_wrong_location": [],
            "duplicate_files": [],
            "temp_files": [],
            "obsolete_files": [],
            "canary_integration_issues": [],
            "missing_integration_structure": []
        }
        
        # Detectar problemas gerais
        for file_path in self.base_path.rglob("*"):
            if file_path.is_file() and not self._is_ignored(file_path):
                if self.is_in_wrong_location(file_path):
                    issues["files_in_wrong_location"].append(file_path)
                elif self.is_temp_file(file_path):
                    issues["temp_files"].append(file_path)
                elif self.is_obsolete(file_path):
                    issues["obsolete_files"].append(file_path)
        
        # Detectar problemas espec√≠ficos de integra√ß√£o Canary
        issues["canary_integration_issues"] = self._detect_canary_integration_issues()
        issues["missing_integration_structure"] = self._detect_missing_integration_structure()
        
        # Detectar duplicatas
        all_files = [f for f in self.base_path.rglob("*") if f.is_file() and not self._is_ignored(f)]
        duplicates = self.find_duplicates(all_files)
        issues["duplicate_files"] = [dup[0] for dup in duplicates]
        
        self.logger.info(f"üîç Problemas detectados: {sum(len(v) for v in issues.values())} total")
        return issues
    
    def _detect_canary_integration_issues(self) -> List[Path]:
        """
        Detecta problemas espec√≠ficos relacionados √† integra√ß√£o Canary.
        
        Returns:
            Lista de arquivos com problemas de integra√ß√£o
        """
        issues = []
        
        # Verificar arquivos de integra√ß√£o fora da estrutura correta
        for file_path in self.base_path.rglob("*"):
            if file_path.is_file() and not self._is_ignored(file_path):
                if self._is_canary_integration_file(file_path):
                    if not self._is_in_correct_canary_location(file_path):
                        issues.append(file_path)
        
        return issues
    
    def _detect_missing_integration_structure(self) -> List[Path]:
        """
        Detecta estrutura de integra√ß√£o faltante.
        
        Returns:
            Lista de diret√≥rios/arquivos faltantes
        """
        missing = []
        
        # Verificar estrutura de integra√ß√£o Canary
        required_structure = [
            self.canary_path,
            self.canary_path / "templates",
            self.canary_path / "workflows", 
            self.canary_path / "validation",
            self.canary_path / "integration",
            self.maps_path / "integration"
        ]
        
        for path in required_structure:
            if not path.exists():
                missing.append(path)
        
        return missing
    
    def _is_canary_integration_file(self, file_path: Path) -> bool:
        """
        Verifica se um arquivo √© relacionado √† integra√ß√£o Canary.
        
        Args:
            file_path: Caminho do arquivo
            
        Returns:
            True se for arquivo de integra√ß√£o Canary
        """
        filename = file_path.name.lower()
        return any(pattern in filename for pattern in ['canary', 'integration', 'template'])
    
    def _is_in_correct_canary_location(self, file_path: Path) -> bool:
        """
        Verifica se um arquivo de integra√ß√£o Canary est√° no local correto.
        
        Args:
            file_path: Caminho do arquivo
            
        Returns:
            True se estiver no local correto
        """
        # Verificar se est√° em uma das pastas de integra√ß√£o Canary
        canary_locations = [
            self.canary_path,
            self.maps_path / "integration"
        ]
        
        return any(str(file_path).startswith(str(loc)) for loc in canary_locations)
    
    def organize_canary_integration_files(self) -> Dict[str, int]:
        """
        Organiza arquivos relacionados √† integra√ß√£o Canary.
        
        Returns:
            Dicion√°rio com estat√≠sticas de organiza√ß√£o
        """
        self.logger.info("üîÑ Organizando arquivos de integra√ß√£o Canary...")
        
        stats = {
            "canary_integration_moved": 0,
            "canary_templates_moved": 0,
            "integration_maps_moved": 0,
            "integration_structure_created": 0
        }
        
        try:
            # Criar estrutura de integra√ß√£o se n√£o existir
            if self._create_canary_integration_structure():
                stats["integration_structure_created"] = 1
            
            # Organizar arquivos de integra√ß√£o Canary
            for file_path in self.base_path.rglob("*"):
                if file_path.is_file() and not self._is_ignored(file_path):
                    if self._is_canary_integration_file(file_path):
                        if self._organize_canary_file(file_path):
                            if "template" in file_path.name.lower():
                                stats["canary_templates_moved"] += 1
                            elif "map" in file_path.name.lower():
                                stats["integration_maps_moved"] += 1
                            else:
                                stats["canary_integration_moved"] += 1
            
            self.logger.info(f"‚úÖ Organiza√ß√£o Canary conclu√≠da: {sum(stats.values())} arquivos processados")
            return stats
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro na organiza√ß√£o Canary: {e}")
            return stats
    
    def _create_canary_integration_structure(self) -> bool:
        """
        Cria estrutura de integra√ß√£o Canary se n√£o existir.
        
        Returns:
            True se estrutura foi criada ou j√° existia
        """
        try:
            structure = {
                'canary_reception': self.canary_path,
                'integration_maps': self.maps_path / 'integration',
                'templates': self.canary_path / 'templates',
                'workflows': self.canary_path / 'workflows',
                'validation': self.canary_path / 'validation',
                'reports': self.log_path / 'integration'
            }
            
            for name, path in structure.items():
                path.mkdir(parents=True, exist_ok=True)
                self.logger.info(f"üìÅ Estrutura Canary: {name} -> {path}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao criar estrutura Canary: {e}")
            return False
    
    def _organize_canary_file(self, file_path: Path) -> bool:
        """
        Organiza um arquivo espec√≠fico de integra√ß√£o Canary.
        
        Args:
            file_path: Caminho do arquivo
            
        Returns:
            True se arquivo foi organizado com sucesso
        """
        try:
            filename = file_path.name.lower()
            
            # Determinar destino baseado no tipo de arquivo
            if "template" in filename:
                destination = self.canary_path / "templates" / file_path.name
            elif "map" in filename and file_path.suffix == ".json":
                destination = self.maps_path / "integration" / file_path.name
            elif "workflow" in filename:
                destination = self.canary_path / "workflows" / file_path.name
            elif "validation" in filename:
                destination = self.canary_path / "validation" / file_path.name
            else:
                destination = self.canary_path / "integration" / file_path.name
            
            # Mover arquivo se n√£o estiver no local correto
            if file_path != destination:
                destination.parent.mkdir(parents=True, exist_ok=True)
                shutil.move(str(file_path), str(destination))
                self.logger.info(f"üìÅ Movido: {file_path.name} -> {destination}")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao organizar arquivo Canary {file_path}: {e}")
            return False
    
    def validate_canary_integration_structure(self) -> Dict[str, any]:
        """
        Valida a estrutura de integra√ß√£o Canary.
        
        Returns:
            Dicion√°rio com resultados da valida√ß√£o
        """
        self.logger.info("üîç Validando estrutura de integra√ß√£o Canary...")
        
        validation = {
            "structure_complete": False,
            "missing_components": [],
            "validation_score": 0,
            "recommendations": []
        }
        
        try:
            # Verificar componentes obrigat√≥rios
            required_components = [
                self.canary_path,
                self.canary_path / "templates",
                self.canary_path / "workflows",
                self.canary_path / "validation",
                self.canary_path / "integration",
                self.maps_path / "integration"
            ]
            
            missing = []
            for component in required_components:
                if not component.exists():
                    missing.append(str(component))
            
            validation["missing_components"] = missing
            validation["structure_complete"] = len(missing) == 0
            
            # Calcular score de valida√ß√£o
            total_components = len(required_components)
            existing_components = total_components - len(missing)
            validation["validation_score"] = (existing_components / total_components) * 100
            
            # Gerar recomenda√ß√µes
            if missing:
                validation["recommendations"].append("Criar estrutura de integra√ß√£o Canary faltante")
            if validation["validation_score"] < 100:
                validation["recommendations"].append("Completar estrutura de integra√ß√£o")
            else:
                validation["recommendations"].append("Estrutura de integra√ß√£o pronta para uso")
            
            self.logger.info(f"‚úÖ Valida√ß√£o Canary: {validation['validation_score']:.1f}%")
            return validation
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro na valida√ß√£o Canary: {e}")
            validation["recommendations"].append(f"Erro na valida√ß√£o: {e}")
            return validation
    
    def is_in_wrong_location(self, file_path: Path) -> bool:
        """Verifica se arquivo est√° no local errado."""
        context = self.detect_file_context(file_path)
        
        if context == "report":
            return not self.is_in_reports_folder(file_path)
        elif context == "task":
            return not self.is_in_tasks_folder(file_path)
        elif context == "recipe":
            return not self.is_in_recipes_folder(file_path)
        elif context == "obsolete":
            return not self.is_in_archives_folder(file_path)
        
        return False
    
    def is_obsolete(self, file_path: Path) -> bool:
        """Verifica se arquivo √© obsoleto."""
        # Verificar padr√µes de obsolesc√™ncia
        for pattern in self.patterns["obsolete"]:
            if file_path.match(pattern):
                return True
        
        # Verificar data de modifica√ß√£o (mais de 30 dias)
        if file_path.exists():
            mtime = datetime.fromtimestamp(file_path.stat().st_mtime)
            if datetime.now() - mtime > timedelta(days=30):
                return True
        
        return False
    
    def is_temp_file(self, file_path: Path) -> bool:
        """Verifica se arquivo √© tempor√°rio."""
        for pattern in self.patterns["temp"]:
            if file_path.match(pattern):
                return True
        return False
    
    def has_category(self, file_path: Path) -> bool:
        """Verifica se arquivo tem categoria definida."""
        context = self.detect_file_context(file_path)
        return context != "other"
    
    def find_duplicates(self, files: List[Path]) -> List[Tuple[Path, Path]]:
        """Encontra arquivos duplicados."""
        duplicates = []
        file_contents = {}
        
        for file_path in files:
            if file_path.exists():
                try:
                    content = file_path.read_text(encoding='utf-8')
                    if content in file_contents:
                        duplicates.append((file_contents[content], file_path))
                    else:
                        file_contents[content] = file_path
                except Exception:
                    continue
        
        return duplicates
    
    def find_unorganized_reports(self) -> List[Path]:
        """Encontra relat√≥rios n√£o organizados."""
        unorganized = []
        
        # Verificar relat√≥rios na raiz da pasta log
        for pattern in self.patterns["report"]:
            for file_path in self.log_path.glob(pattern):
                if file_path.parent == self.log_path:  # Est√° na raiz
                    unorganized.append(file_path)
        
        return unorganized
    
    def detect_file_context(self, file_path: Path) -> str:
        """Detecta contexto do arquivo automaticamente."""
        for context, pattern_list in self.patterns.items():
            for pattern in pattern_list:
                if file_path.match(pattern):
                    return context
        return "other"
    
    def is_in_reports_folder(self, file_path: Path) -> bool:
        """Verifica se arquivo est√° na pasta de relat√≥rios."""
        return "reports" in str(file_path)
    
    def is_in_tasks_folder(self, file_path: Path) -> bool:
        """Verifica se arquivo est√° na pasta de tarefas."""
        return "completed_tasks" in str(file_path) or "temp_tasks" in str(file_path)
    
    def is_in_recipes_folder(self, file_path: Path) -> bool:
        """Verifica se arquivo est√° na pasta de receitas."""
        return "recipes" in str(file_path)
    
    def is_in_archives_folder(self, file_path: Path) -> bool:
        """Verifica se arquivo est√° na pasta de arquivos."""
        return "archives" in str(file_path)
    
    def organize_by_category(self) -> Dict[str, int]:
        """
        Organiza arquivos por categoria automaticamente.
        
        Returns:
            Dicion√°rio com n√∫mero de arquivos organizados por categoria
        """
        self.logger.info("üì¶ Organizando arquivos por categoria...")
        
        organized_count = {}
        
        for category, config in self.categories.items():
            organized_count[category] = 0
            
            # Criar pasta de destino se n√£o existir
            config["destination"].mkdir(parents=True, exist_ok=True)
            
            # Encontrar arquivos da categoria
            for pattern in config["patterns"]:
                for file_path in self.log_path.rglob(pattern):
                    if file_path.parent != config["destination"]:
                        try:
                            # Mover arquivo
                            new_path = config["destination"] / file_path.name
                            
                            # Evitar sobrescrever arquivos existentes
                            if new_path.exists():
                                counter = 1
                                while new_path.exists():
                                    name = file_path.stem + f"_{counter}" + file_path.suffix
                                    new_path = config["destination"] / name
                                    counter += 1
                            
                            shutil.move(str(file_path), str(new_path))
                            organized_count[category] += 1
                            self.logger.info(f"  ‚úÖ Movido: {file_path.name} ‚Üí {category}")
                            
                        except Exception as e:
                            self.logger.error(f"  ‚ùå Erro ao mover {file_path.name}: {e}")
        
        self.logger.info(f"üìä Organiza√ß√£o conclu√≠da: {sum(organized_count.values())} arquivos")
        return organized_count
    
    def organize_by_date(self) -> Dict[str, int]:
        """
        Organiza relat√≥rios por data automaticamente.
        
        Returns:
            Dicion√°rio com n√∫mero de relat√≥rios organizados por m√™s
        """
        self.logger.info("üìÖ Organizando relat√≥rios por data...")
        
        organized_count = {}
        reports_dir = self.log_path / "reports"
        reports_dir.mkdir(exist_ok=True)
        
        # Encontrar todos os relat√≥rios
        for pattern in self.patterns["report"]:
            for file_path in self.log_path.rglob(pattern):
                if file_path.exists():
                    try:
                        # Extrair data do arquivo ou usar data de modifica√ß√£o
                        file_date = self.extract_date_from_file(file_path)
                        
                        # Criar pasta do m√™s
                        month_dir = reports_dir / file_date.strftime("%Y-%m")
                        month_dir.mkdir(exist_ok=True)
                        
                        # Mover arquivo
                        new_path = month_dir / file_path.name
                        
                        # Evitar sobrescrever
                        if new_path.exists():
                            counter = 1
                            while new_path.exists():
                                name = file_path.stem + f"_{counter}" + file_path.suffix
                                new_path = month_dir / name
                                counter += 1
                        
                        shutil.move(str(file_path), str(new_path))
                        
                        month_key = file_date.strftime("%Y-%m")
                        organized_count[month_key] = organized_count.get(month_key, 0) + 1
                        
                        self.logger.info(f"  ‚úÖ Organizado por data: {file_path.name} ‚Üí {month_key}")
                        
                    except Exception as e:
                        self.logger.error(f"  ‚ùå Erro ao organizar por data {file_path.name}: {e}")
        
        self.logger.info(f"üìä Organiza√ß√£o por data conclu√≠da: {sum(organized_count.values())} relat√≥rios")
        return organized_count
    
    def extract_date_from_file(self, file_path: Path) -> datetime:
        """Extrai data do arquivo ou usa data de modifica√ß√£o."""
        # Tentar extrair data do nome do arquivo
        date_patterns = [
            r'(\d{4}-\d{2}-\d{2})',
            r'(\d{4}_\d{2}_\d{2})',
            r'(\d{8})'
        ]
        
        for pattern in date_patterns:
            match = re.search(pattern, file_path.name)
            if match:
                date_str = match.group(1)
                try:
                    if '_' in date_str:
                        date_str = date_str.replace('_', '-')
                    elif len(date_str) == 8:
                        date_str = f"{date_str[:4]}-{date_str[4:6]}-{date_str[6:8]}"
                    return datetime.strptime(date_str, "%Y-%m-%d")
                except ValueError:
                    continue
        
        # Usar data de modifica√ß√£o
        return datetime.fromtimestamp(file_path.stat().st_mtime)
    
    def cleanup_temp_files(self) -> int:
        """
        Remove arquivos tempor√°rios automaticamente.
        
        Returns:
            N√∫mero de arquivos removidos
        """
        self.logger.info("üßπ Limpando arquivos tempor√°rios...")
        
        removed_count = 0
        
        for pattern in self.patterns["temp"]:
            for file_path in self.log_path.rglob(pattern):
                if file_path.exists():
                    try:
                        file_path.unlink()
                        removed_count += 1
                        self.logger.info(f"  üóëÔ∏è Removido: {file_path.name}")
                    except Exception as e:
                        self.logger.error(f"  ‚ùå Erro ao remover {file_path.name}: {e}")
        
        self.logger.info(f"üìä Limpeza conclu√≠da: {removed_count} arquivos removidos")
        return removed_count
    
    def remove_duplicates(self) -> int:
        """
        Remove arquivos duplicados.
        
        Returns:
            N√∫mero de duplicatas removidas
        """
        self.logger.info("üîç Removendo arquivos duplicados...")
        
        removed_count = 0
        files = list(self.log_path.rglob("*.md"))
        files.extend(list(self.log_path.rglob("*.json")))
        
        duplicates = self.find_duplicates(files)
        
        for original, duplicate in duplicates:
            try:
                duplicate.unlink()
                removed_count += 1
                self.logger.info(f"  üóëÔ∏è Duplicata removida: {duplicate.name}")
            except Exception as e:
                self.logger.error(f"  ‚ùå Erro ao remover duplicata {duplicate.name}: {e}")
        
        self.logger.info(f"üìä Remo√ß√£o de duplicatas conclu√≠da: {removed_count} arquivos")
        return removed_count
    
    def create_organization_structure(self) -> bool:
        """
        Cria estrutura de organiza√ß√£o padr√£o.
        
        Returns:
            True se estrutura foi criada com sucesso
        """
        self.logger.info("üèóÔ∏è Criando estrutura de organiza√ß√£o...")
        
        try:
            # Estrutura de pastas obrigat√≥ria
            structure = {
                "reports": {
                    "current": self.log_path / "reports" / "current",
                    "2025-01": self.log_path / "reports" / "2025-01",
                    "2025-02": self.log_path / "reports" / "2025-02"
                },
                "completed_tasks": {
                    "system_updates": self.log_path / "completed_tasks" / "system_updates",
                    "feature_implementations": self.log_path / "completed_tasks" / "feature_implementations",
                    "bug_fixes": self.log_path / "completed_tasks" / "bug_fixes"
                },
                "archives": {
                    "obsolete_files": self.log_path / "archives" / "obsolete_files",
                    "historical_data": self.log_path / "archives" / "historical_data",
                    "old_reports": self.log_path / "archives" / "old_reports"
                },
                "recipes": self.log_path / "recipes",
                "learning": self.log_path / "learning",
                "python_agent": self.log_path / "python_agent",
                "aaa_validation": self.log_path / "aaa_validation",
                "aaa_fixes": self.log_path / "aaa_fixes",
                "temp_tasks": self.log_path / "temp_tasks"
            }
            
            # Criar todas as pastas
            for category, paths in structure.items():
                if isinstance(paths, dict):
                    for subcategory, path in paths.items():
                        path.mkdir(parents=True, exist_ok=True)
                        self.logger.info(f"  ‚úÖ Criada pasta: {path}")
                else:
                    paths.mkdir(parents=True, exist_ok=True)
                    self.logger.info(f"  ‚úÖ Criada pasta: {paths}")
            
            self.logger.info("‚úÖ Estrutura de organiza√ß√£o criada com sucesso")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao criar estrutura: {e}")
            return False
    
    def generate_organization_report(self, results: Dict[str, Any]) -> str:
        """
        Gera relat√≥rio de organiza√ß√£o.
        
        Args:
            results: Resultados da organiza√ß√£o
            
        Returns:
            Relat√≥rio em formato markdown
        """
        report = f"""# Relat√≥rio de Organiza√ß√£o Inteligente

**Data**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Agente**: Intelligent Organization Agent  
**Status**: ‚úÖ **ORGANIZA√á√ÉO CONCLU√çDA**

---

## üìä Resumo da Organiza√ß√£o

### **Problemas Detectados**:
- **Arquivos no local errado**: {len(results.get('issues', {}).get('files_in_wrong_location', []))}
- **Arquivos duplicados**: {len(results.get('issues', {}).get('duplicate_files', []))}
- **Arquivos obsoletos**: {len(results.get('issues', {}).get('obsolete_files', []))}
- **Relat√≥rios n√£o organizados**: {len(results.get('issues', {}).get('unorganized_reports', []))}
- **Arquivos tempor√°rios**: {len(results.get('issues', {}).get('temp_files_not_cleaned', []))}

### **A√ß√µes Realizadas**:
- **Arquivos organizados por categoria**: {sum(results.get('organized_by_category', {}).values())}
- **Relat√≥rios organizados por data**: {sum(results.get('organized_by_date', {}).values())}
- **Arquivos tempor√°rios removidos**: {results.get('temp_files_removed', 0)}
- **Duplicatas removidas**: {results.get('duplicates_removed', 0)}

---

## üìÅ Estrutura Criada

### **Pastas de Relat√≥rios**:
- `reports/current/` - Relat√≥rios atuais
- `reports/2025-01/` - Relat√≥rios de janeiro 2025
- `reports/2025-02/` - Relat√≥rios de fevereiro 2025

### **Pastas de Tarefas**:
- `completed_tasks/system_updates/` - Atualiza√ß√µes do sistema
- `completed_tasks/feature_implementations/` - Implementa√ß√µes de features
- `completed_tasks/bug_fixes/` - Corre√ß√µes de bugs

### **Pastas de Arquivo**:
- `archives/obsolete_files/` - Arquivos obsoletos
- `archives/historical_data/` - Dados hist√≥ricos
- `archives/old_reports/` - Relat√≥rios antigos

---

## üéØ Benef√≠cios Alcan√ßados

### **üßπ Organiza√ß√£o**:
- ‚úÖ Sistema limpo e organizado
- ‚úÖ Arquivos f√°ceis de encontrar
- ‚úÖ Estrutura consistente
- ‚úÖ Hist√≥rico rastre√°vel

### **üìä Efici√™ncia**:
- ‚úÖ Busca r√°pida de informa√ß√µes
- ‚úÖ Navega√ß√£o intuitiva
- ‚úÖ Manuten√ß√£o simplificada
- ‚úÖ Produtividade aumentada

---

## üìù Pr√≥ximos Passos

1. **Monitoramento cont√≠nuo** da organiza√ß√£o
2. **Execu√ß√£o autom√°tica** di√°ria
3. **Valida√ß√£o peri√≥dica** da estrutura
4. **Otimiza√ß√£o cont√≠nua** do sistema

---

*Relat√≥rio gerado automaticamente pelo Intelligent Organization Agent*
"""
        
        return report
    
    def run_full_organization(self) -> Dict[str, Any]:
        """
        Executa organiza√ß√£o completa do sistema.
        
        Returns:
            Resultados da organiza√ß√£o
        """
        self.logger.info("üöÄ Iniciando organiza√ß√£o completa do sistema...")
        
        try:
            # 1. Criar estrutura de organiza√ß√£o
            structure_created = self.create_organization_structure()
            
            # 2. Detectar problemas
            issues = self.detect_organization_issues()
            
            # 3. Organizar por categoria
            organized_by_category = self.organize_by_category()
            
            # 4. Organizar por data
            organized_by_date = self.organize_by_date()
            
            # 5. Limpar arquivos tempor√°rios
            temp_files_removed = self.cleanup_temp_files()
            
            # 6. Remover duplicatas
            duplicates_removed = self.remove_duplicates()
            
            # 7. Gerar relat√≥rio
            results = {
                "timestamp": datetime.now().isoformat(),
                "structure_created": structure_created,
                "issues": issues,
                "organized_by_category": organized_by_category,
                "organized_by_date": organized_by_date,
                "temp_files_removed": temp_files_removed,
                "duplicates_removed": duplicates_removed,
                "success": True
            }
            
            # Salvar relat√≥rio
            report_content = self.generate_organization_report(results)
            report_path = self.log_path / "reports" / "current" / f"ORGANIZATION_REPORT_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
            report_path.parent.mkdir(parents=True, exist_ok=True)
            report_path.write_text(report_content, encoding='utf-8')
            
            self.logger.info("‚úÖ Organiza√ß√£o completa conclu√≠da com sucesso!")
            return results
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro durante organiza√ß√£o: {e}")
            return {
                "timestamp": datetime.now().isoformat(),
                "success": False,
                "error": str(e)
            }

    def _is_ignored(self, file_path: Path) -> bool:
        """
        Verifica se um arquivo deve ser ignorado pela organiza√ß√£o.
        
        Args:
            file_path: Caminho do arquivo
            
        Returns:
            True se o arquivo deve ser ignorado
        """
        # Ignorar arquivos do sistema
        ignored_patterns = [
            '.git',
            '.gitignore',
            '__pycache__',
            '.pyc',
            '.DS_Store',
            'Thumbs.db',
            '.obsidian'
        ]
        
        # Ignorar subm√≥dulos (fontes de verdade imut√°veis)
        submodule_patterns = [
            'otclient/',
            'canary/'
        ]
        
        file_str = str(file_path)
        
        # Verificar padr√µes do sistema
        if any(pattern in file_str for pattern in ignored_patterns):
            return True
        
        # Verificar se est√° em subm√≥dulo (n√£o deve ser organizado)
        if any(pattern in file_str for pattern in submodule_patterns):
            return True
        
        return False

def main():
    """Fun√ß√£o principal."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Agente de Organiza√ß√£o Inteligente')
    parser.add_argument('--full', action='store_true', help='Executar organiza√ß√£o completa')
    parser.add_argument('--detect', action='store_true', help='Apenas detectar problemas')
    parser.add_argument('--cleanup', action='store_true', help='Apenas limpeza de arquivos tempor√°rios')
    parser.add_argument('--organize', action='store_true', help='Apenas organiza√ß√£o por categoria')
    
    args = parser.parse_args()
    
    agent = IntelligentOrganizationAgent()
    
    if args.detect:
        issues = agent.detect_organization_issues()
        print("üîç Problemas detectados:")
        for issue_type, files in issues.items():
            print(f"  {issue_type}: {len(files)} arquivos")
    
    elif args.cleanup:
        removed = agent.cleanup_temp_files()
        print(f"üßπ {removed} arquivos tempor√°rios removidos")
    
    elif args.organize:
        organized = agent.organize_by_category()
        print("üì¶ Arquivos organizados por categoria:")
        for category, count in organized.items():
            print(f"  {category}: {count} arquivos")
    
    elif args.full:
        results = agent.run_full_organization()
        if results["success"]:
            print("‚úÖ Organiza√ß√£o completa conclu√≠da!")
            print(f"üìä {sum(results['organized_by_category'].values())} arquivos organizados")
            print(f"üßπ {results['temp_files_removed']} arquivos tempor√°rios removidos")
        else:
            print(f"‚ùå Erro: {results['error']}")
    
    else:
        # Modo padr√£o: organiza√ß√£o completa
        results = agent.run_full_organization()
        if results["success"]:
            print("‚úÖ Organiza√ß√£o completa conclu√≠da!")
        else:
            print(f"‚ùå Erro: {results['error']}")

if __name__ == '__main__':
    main() 

# Fun√ß√£o de integra√ß√£o com o m√≥dulo
def integrate_with_module():
    """Integra o script com o m√≥dulo de destino."""
    module = AgentorchestratorModule()
    return module.execute()

if __name__ == "__main__":
    # Executar integra√ß√£o com m√≥dulo
    result = integrate_with_module()
    if result:
        print(f"‚úÖ Script intelligent_organization_agent.py executado com sucesso via m√≥dulo agents.agent_orchestrator")
    else:
        print(f"‚ùå Erro na execu√ß√£o do script intelligent_organization_agent.py via m√≥dulo agents.agent_orchestrator")
