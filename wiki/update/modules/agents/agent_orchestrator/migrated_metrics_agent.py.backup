#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script Migrado: metrics_agent.py
M√≥dulo de Destino: agents.agent_orchestrator
Data de Migra√ß√£o: 2025-08-01 12:21:43

Script original migrado para a estrutura modular unificada.
"""

# Imports do m√≥dulo
from . import AgentorchestratorModule

# Conte√∫do original do script
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Metrics Agent - Sistema de M√©tricas e Feedback

Este agente √© respons√°vel por:
- Coletar m√©tricas de performance e uso do sistema
- Monitorar KPIs cr√≠ticos
- Gerar relat√≥rios de performance
- Identificar gargalos e oportunidades de otimiza√ß√£o
- Fornecer insights para melhorias cont√≠nuas
"""

import json
import logging
import time
import psutil
import os
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
import re
import statistics

class MetricsAgent:
    def __init__(self):
        self.base_path = Path(__file__).parent.parent.parent
        self.metrics_path = self.base_path / "wiki" / "log" / "metrics"
        self.dashboard_path = self.base_path / "wiki" / "dashboard"
        self.agents_path = self.base_path / "wiki" / "bmad" / "agents"
        
        # Criar pasta de m√©tricas se n√£o existir
        self.metrics_path.mkdir(parents=True, exist_ok=True)
        
        # Configurar logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger('MetricsAgent')
        
        # Carregar configura√ß√µes
        self.load_configuration()
        
        # Hist√≥rico de m√©tricas
        self.metrics_history = []
        self.performance_data = []
        
    def load_configuration(self):
        """Carrega configura√ß√µes do sistema de m√©tricas"""
        self.logger.info("üîß Carregando configura√ß√µes do Metrics Agent...")
        
        # Configura√ß√µes padr√£o
        self.config = {
            "metrics_file": "system_metrics.json",
            "performance_file": "performance_metrics.json",
            "history_file": "metrics_history.json",
            "dashboard_file": "metrics_dashboard.json",
            "update_interval": 60,  # 1 minuto
            "collection_duration": 3600,  # 1 hora
            "kpi_targets": {
                "cpu_usage": 70.0,  # M√°ximo 70%
                "memory_usage": 80.0,  # M√°ximo 80%
                "disk_usage": 85.0,  # M√°ximo 85%
                "response_time": 2.0,  # M√°ximo 2 segundos
                "task_completion_rate": 95.0,  # M√≠nimo 95%
                "agent_availability": 98.0,  # M√≠nimo 98%
                "file_processing_speed": 100.0,  # M√≠nimo 100 arquivos/min
                "error_rate": 2.0,  # M√°ximo 2%
                "cache_hit_rate": 90.0,  # M√≠nimo 90%
                "system_uptime": 99.5  # M√≠nimo 99.5%
            },
            "alert_thresholds": {
                "critical": 0.9,  # 90% do limite
                "warning": 0.7,   # 70% do limite
                "info": 0.5       # 50% do limite
            }
        }
        
        self.logger.info("‚úÖ Configura√ß√µes carregadas com sucesso")
    
    def collect_system_metrics(self) -> Dict[str, Any]:
        """Coleta m√©tricas do sistema operacional"""
        self.logger.info("üìä Coletando m√©tricas do sistema...")
        
        try:
            # M√©tricas de CPU
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            cpu_freq = psutil.cpu_freq()
            
            # M√©tricas de mem√≥ria
            memory = psutil.virtual_memory()
            swap = psutil.swap_memory()
            
            # M√©tricas de disco
            disk = psutil.disk_usage('/')
            disk_io = psutil.disk_io_counters()
            
            # M√©tricas de rede
            network = psutil.net_io_counters()
            
            # M√©tricas de processos
            process_count = len(psutil.pids())
            
            # M√©tricas de tempo
            boot_time = psutil.boot_time()
            uptime = time.time() - boot_time
            
            metrics = {
                "timestamp": datetime.now().isoformat(),
                "cpu": {
                    "usage_percent": cpu_percent,
                    "count": cpu_count,
                    "frequency_mhz": cpu_freq.current if cpu_freq else 0,
                    "frequency_max_mhz": cpu_freq.max if cpu_freq else 0
                },
                "memory": {
                    "total_gb": memory.total / (1024**3),
                    "available_gb": memory.available / (1024**3),
                    "used_gb": memory.used / (1024**3),
                    "usage_percent": memory.percent,
                    "swap_total_gb": swap.total / (1024**3),
                    "swap_used_gb": swap.used / (1024**3),
                    "swap_usage_percent": swap.percent
                },
                "disk": {
                    "total_gb": disk.total / (1024**3),
                    "used_gb": disk.used / (1024**3),
                    "free_gb": disk.free / (1024**3),
                    "usage_percent": (disk.used / disk.total) * 100,
                    "read_bytes": disk_io.read_bytes if disk_io else 0,
                    "write_bytes": disk_io.write_bytes if disk_io else 0
                },
                "network": {
                    "bytes_sent": network.bytes_sent,
                    "bytes_recv": network.bytes_recv,
                    "packets_sent": network.packets_sent,
                    "packets_recv": network.packets_recv
                },
                "system": {
                    "process_count": process_count,
                    "uptime_seconds": uptime,
                    "uptime_hours": uptime / 3600,
                    "boot_time": datetime.fromtimestamp(boot_time).isoformat()
                }
            }
            
            self.logger.info(f"‚úÖ M√©tricas do sistema coletadas: CPU {cpu_percent:.1f}%, Mem√≥ria {memory.percent:.1f}%")
            return metrics
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao coletar m√©tricas do sistema: {e}")
            return {}
    
    def collect_application_metrics(self) -> Dict[str, Any]:
        """Coleta m√©tricas espec√≠ficas da aplica√ß√£o"""
        self.logger.info("üìä Coletando m√©tricas da aplica√ß√£o...")
        
        try:
            # M√©tricas de arquivos
            total_files = self.count_files_in_directory(self.base_path)
            json_files = self.count_files_by_extension(self.base_path, '.json')
            python_files = self.count_files_by_extension(self.base_path, '.py')
            markdown_files = self.count_files_by_extension(self.base_path, '.md')
            
            # M√©tricas de agentes
            agent_files = self.count_files_in_directory(self.agents_path)
            active_agents = self.get_active_agents()
            
            # M√©tricas de tarefas
            task_metrics = self.get_task_metrics()
            
            # M√©tricas de performance
            performance_metrics = self.get_performance_metrics()
            
            metrics = {
                "timestamp": datetime.now().isoformat(),
                "files": {
                    "total_files": total_files,
                    "json_files": json_files,
                    "python_files": python_files,
                    "markdown_files": markdown_files,
                    "agent_files": agent_files
                },
                "agents": {
                    "total_agents": agent_files,
                    "active_agents": active_agents,
                    "availability_percent": (active_agents / agent_files * 100) if agent_files > 0 else 0
                },
                "tasks": task_metrics,
                "performance": performance_metrics
            }
            
            self.logger.info(f"‚úÖ M√©tricas da aplica√ß√£o coletadas: {total_files} arquivos, {active_agents} agentes ativos")
            return metrics
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao coletar m√©tricas da aplica√ß√£o: {e}")
            return {}
    
    def count_files_in_directory(self, directory: Path) -> int:
        """Conta arquivos em um diret√≥rio"""
        try:
            count = 0
            for root, dirs, files in os.walk(directory):
                count += len(files)
            return count
        except Exception:
            return 0
    
    def count_files_by_extension(self, directory: Path, extension: str) -> int:
        """Conta arquivos por extens√£o"""
        try:
            count = 0
            for root, dirs, files in os.walk(directory):
                count += len([f for f in files if f.endswith(extension)])
            return count
        except Exception:
            return 0
    
    def get_active_agents(self) -> int:
        """Conta agentes ativos"""
        try:
            active_count = 0
            for agent_file in self.agents_path.glob('*.py'):
                if agent_file.name != '__init__.py':
                    # Verificar se o arquivo foi modificado nas √∫ltimas 24 horas
                    if (datetime.now() - datetime.fromtimestamp(agent_file.stat().st_mtime)).days < 1:
                        active_count += 1
            return active_count
        except Exception:
            return 0
    
    def get_task_metrics(self) -> Dict[str, Any]:
        """Obt√©m m√©tricas de tarefas"""
        try:
            task_master_file = self.dashboard_path / "task_master.md"
            
            if not task_master_file.exists():
                return {"total_tasks": 0, "completed_tasks": 0, "completion_rate": 0}
            
            with open(task_master_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Contar tarefas completas e totais
            completed_tasks = len(re.findall(r'‚úÖ.*COMPLETA', content))
            total_tasks = len(re.findall(r'\[.*\]\s*\*\*[0-9]+\.[0-9]+\*\*', content))
            
            completion_rate = (completed_tasks / total_tasks * 100) if total_tasks > 0 else 0
            
            return {
                "total_tasks": total_tasks,
                "completed_tasks": completed_tasks,
                "completion_rate": completion_rate,
                "pending_tasks": total_tasks - completed_tasks
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao obter m√©tricas de tarefas: {e}")
            return {"total_tasks": 0, "completed_tasks": 0, "completion_rate": 0}
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """Obt√©m m√©tricas de performance"""
        try:
            # Calcular tempo de resposta m√©dio (simulado)
            response_times = [0.5, 1.2, 0.8, 1.5, 0.9, 1.1, 0.7, 1.3, 0.6, 1.0]
            avg_response_time = statistics.mean(response_times)
            max_response_time = max(response_times)
            min_response_time = min(response_times)
            
            # Calcular taxa de erro (simulada)
            error_rate = 1.2  # 1.2%
            
            # Calcular taxa de cache hit (simulada)
            cache_hit_rate = 94.5  # 94.5%
            
            return {
                "response_time_avg_seconds": avg_response_time,
                "response_time_max_seconds": max_response_time,
                "response_time_min_seconds": min_response_time,
                "error_rate_percent": error_rate,
                "cache_hit_rate_percent": cache_hit_rate,
                "file_processing_speed_files_per_min": 150.0
            }
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao obter m√©tricas de performance: {e}")
            return {}
    
    def calculate_kpis(self, system_metrics: Dict, app_metrics: Dict) -> Dict[str, Any]:
        """Calcula KPIs baseados nas m√©tricas coletadas"""
        self.logger.info("üìä Calculando KPIs...")
        
        try:
            kpis = {
                "timestamp": datetime.now().isoformat(),
                "system_kpis": {},
                "application_kpis": {},
                "overall_score": 0.0,
                "alerts": []
            }
            
            # KPIs do sistema
            if system_metrics:
                cpu_usage = system_metrics.get('cpu', {}).get('usage_percent', 0)
                memory_usage = system_metrics.get('memory', {}).get('usage_percent', 0)
                disk_usage = system_metrics.get('disk', {}).get('usage_percent', 0)
                uptime_hours = system_metrics.get('system', {}).get('uptime_hours', 0)
                
                kpis["system_kpis"] = {
                    "cpu_usage_percent": cpu_usage,
                    "memory_usage_percent": memory_usage,
                    "disk_usage_percent": disk_usage,
                    "uptime_hours": uptime_hours,
                    "system_health_score": self.calculate_health_score(cpu_usage, memory_usage, disk_usage)
                }
            
            # KPIs da aplica√ß√£o
            if app_metrics:
                task_completion = app_metrics.get('tasks', {}).get('completion_rate', 0)
                agent_availability = app_metrics.get('agents', {}).get('availability_percent', 0)
                performance = app_metrics.get('performance', {})
                response_time = performance.get('response_time_avg_seconds', 0)
                error_rate = performance.get('error_rate_percent', 0)
                cache_hit_rate = performance.get('cache_hit_rate_percent', 0)
                
                kpis["application_kpis"] = {
                    "task_completion_rate": task_completion,
                    "agent_availability": agent_availability,
                    "response_time_seconds": response_time,
                    "error_rate_percent": error_rate,
                    "cache_hit_rate_percent": cache_hit_rate,
                    "application_health_score": self.calculate_app_health_score(
                        task_completion, agent_availability, response_time, error_rate, cache_hit_rate
                    )
                }
            
            # Score geral
            system_score = kpis["system_kpis"].get("system_health_score", 0)
            app_score = kpis["application_kpis"].get("application_health_score", 0)
            kpis["overall_score"] = (system_score + app_score) / 2
            
            # Gerar alertas
            kpis["alerts"] = self.generate_alerts(kpis)
            
            self.logger.info(f"‚úÖ KPIs calculados: Score geral {kpis['overall_score']:.1f}")
            return kpis
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao calcular KPIs: {e}")
            return {}
    
    def calculate_health_score(self, cpu: float, memory: float, disk: float) -> float:
        """Calcula score de sa√∫de do sistema"""
        try:
            # Normalizar valores (0-100)
            cpu_score = max(0, 100 - cpu)
            memory_score = max(0, 100 - memory)
            disk_score = max(0, 100 - disk)
            
            # Peso: CPU 40%, Mem√≥ria 35%, Disco 25%
            health_score = (cpu_score * 0.4) + (memory_score * 0.35) + (disk_score * 0.25)
            return min(100, max(0, health_score))
        except Exception:
            return 0
    
    def calculate_app_health_score(self, task_completion: float, agent_availability: float, 
                                 response_time: float, error_rate: float, cache_hit_rate: float) -> float:
        """Calcula score de sa√∫de da aplica√ß√£o"""
        try:
            # Normalizar valores
            task_score = min(100, task_completion)
            agent_score = min(100, agent_availability)
            response_score = max(0, 100 - (response_time * 50))  # Penalizar tempos altos
            error_score = max(0, 100 - error_rate * 10)  # Penalizar taxas de erro
            cache_score = min(100, cache_hit_rate)
            
            # Peso: Tarefas 30%, Agentes 25%, Performance 20%, Erros 15%, Cache 10%
            health_score = (task_score * 0.3) + (agent_score * 0.25) + (response_score * 0.2) + \
                          (error_score * 0.15) + (cache_score * 0.1)
            return min(100, max(0, health_score))
        except Exception:
            return 0
    
    def generate_alerts(self, kpis: Dict) -> List[Dict]:
        """Gera alertas baseados nos KPIs"""
        alerts = []
        
        try:
            system_kpis = kpis.get("system_kpis", {})
            app_kpis = kpis.get("application_kpis", {})
            
            # Alertas do sistema
            cpu_usage = system_kpis.get("cpu_usage_percent", 0)
            memory_usage = system_kpis.get("memory_usage_percent", 0)
            disk_usage = system_kpis.get("disk_usage_percent", 0)
            
            if cpu_usage > self.config["kpi_targets"]["cpu_usage"] * self.config["alert_thresholds"]["critical"]:
                alerts.append({
                    "type": "critical",
                    "component": "system",
                    "metric": "cpu_usage",
                    "value": cpu_usage,
                    "threshold": self.config["kpi_targets"]["cpu_usage"],
                    "message": f"Uso de CPU cr√≠tico: {cpu_usage:.1f}%"
                })
            elif cpu_usage > self.config["kpi_targets"]["cpu_usage"] * self.config["alert_thresholds"]["warning"]:
                alerts.append({
                    "type": "warning",
                    "component": "system",
                    "metric": "cpu_usage",
                    "value": cpu_usage,
                    "threshold": self.config["kpi_targets"]["cpu_usage"],
                    "message": f"Uso de CPU alto: {cpu_usage:.1f}%"
                })
            
            if memory_usage > self.config["kpi_targets"]["memory_usage"] * self.config["alert_thresholds"]["critical"]:
                alerts.append({
                    "type": "critical",
                    "component": "system",
                    "metric": "memory_usage",
                    "value": memory_usage,
                    "threshold": self.config["kpi_targets"]["memory_usage"],
                    "message": f"Uso de mem√≥ria cr√≠tico: {memory_usage:.1f}%"
                })
            
            if disk_usage > self.config["kpi_targets"]["disk_usage"] * self.config["alert_thresholds"]["critical"]:
                alerts.append({
                    "type": "critical",
                    "component": "system",
                    "metric": "disk_usage",
                    "value": disk_usage,
                    "threshold": self.config["kpi_targets"]["disk_usage"],
                    "message": f"Uso de disco cr√≠tico: {disk_usage:.1f}%"
                })
            
            # Alertas da aplica√ß√£o
            task_completion = app_kpis.get("task_completion_rate", 0)
            error_rate = app_kpis.get("error_rate_percent", 0)
            
            if task_completion < self.config["kpi_targets"]["task_completion_rate"] * self.config["alert_thresholds"]["warning"]:
                alerts.append({
                    "type": "warning",
                    "component": "application",
                    "metric": "task_completion",
                    "value": task_completion,
                    "threshold": self.config["kpi_targets"]["task_completion_rate"],
                    "message": f"Taxa de conclus√£o de tarefas baixa: {task_completion:.1f}%"
                })
            
            if error_rate > self.config["kpi_targets"]["error_rate"] * self.config["alert_thresholds"]["critical"]:
                alerts.append({
                    "type": "critical",
                    "component": "application",
                    "metric": "error_rate",
                    "value": error_rate,
                    "threshold": self.config["kpi_targets"]["error_rate"],
                    "message": f"Taxa de erro cr√≠tica: {error_rate:.1f}%"
                })
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao gerar alertas: {e}")
        
        return alerts
    
    def save_metrics(self, metrics: Dict, filename: str) -> bool:
        """Salva m√©tricas em arquivo JSON"""
        try:
            file_path = self.metrics_path / filename
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(metrics, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"‚úÖ M√©tricas salvas em: {file_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao salvar m√©tricas: {e}")
            return False
    
    def generate_metrics_report(self) -> str:
        """Gera relat√≥rio de m√©tricas"""
        self.logger.info("üìä Gerando relat√≥rio de m√©tricas...")
        
        try:
            # Carregar m√©tricas mais recentes
            system_metrics_file = self.metrics_path / self.config["metrics_file"]
            kpis_file = self.metrics_path / self.config["dashboard_file"]
            
            system_metrics = {}
            kpis = {}
            
            if system_metrics_file.exists():
                with open(system_metrics_file, 'r', encoding='utf-8') as f:
                    system_metrics = json.load(f)
            
            if kpis_file.exists():
                with open(kpis_file, 'r', encoding='utf-8') as f:
                    kpis = json.load(f)
            
            # Gerar relat√≥rio
            report = f"""
# üìä Relat√≥rio de M√©tricas do Sistema

**Data/Hora**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## üñ•Ô∏è M√©tricas do Sistema

### CPU
- **Uso**: {system_metrics.get('cpu', {}).get('usage_percent', 0):.1f}%
- **N√∫cleos**: {system_metrics.get('cpu', {}).get('count', 0)}
- **Frequ√™ncia**: {system_metrics.get('cpu', {}).get('frequency_mhz', 0):.0f} MHz

### Mem√≥ria
- **Total**: {system_metrics.get('memory', {}).get('total_gb', 0):.1f} GB
- **Usado**: {system_metrics.get('memory', {}).get('used_gb', 0):.1f} GB
- **Uso**: {system_metrics.get('memory', {}).get('usage_percent', 0):.1f}%

### Disco
- **Total**: {system_metrics.get('disk', {}).get('total_gb', 0):.1f} GB
- **Usado**: {system_metrics.get('disk', {}).get('used_gb', 0):.1f} GB
- **Uso**: {system_metrics.get('disk', {}).get('usage_percent', 0):.1f}%

### Sistema
- **Processos**: {system_metrics.get('system', {}).get('process_count', 0)}
- **Uptime**: {system_metrics.get('system', {}).get('uptime_hours', 0):.1f} horas

## üìà KPIs

### Score Geral
- **Score do Sistema**: {kpis.get('system_kpis', {}).get('system_health_score', 0):.1f}/100
- **Score da Aplica√ß√£o**: {kpis.get('application_kpis', {}).get('application_health_score', 0):.1f}/100
- **Score Geral**: {kpis.get('overall_score', 0):.1f}/100

### Aplica√ß√£o
- **Taxa de Conclus√£o de Tarefas**: {kpis.get('application_kpis', {}).get('task_completion_rate', 0):.1f}%
- **Disponibilidade de Agentes**: {kpis.get('application_kpis', {}).get('agent_availability', 0):.1f}%
- **Tempo de Resposta**: {kpis.get('application_kpis', {}).get('response_time_seconds', 0):.2f}s
- **Taxa de Erro**: {kpis.get('application_kpis', {}).get('error_rate_percent', 0):.1f}%
- **Taxa de Cache Hit**: {kpis.get('application_kpis', {}).get('cache_hit_rate_percent', 0):.1f}%

## üö® Alertas

"""
            
            alerts = kpis.get('alerts', [])
            if alerts:
                for alert in alerts:
                    report += f"- **{alert['type'].upper()}**: {alert['message']}\n"
            else:
                report += "- ‚úÖ Nenhum alerta ativo\n"
            
            report += f"""
## üìã Status

- **Sistema**: {'üü¢ Saud√°vel' if kpis.get('overall_score', 0) >= 80 else 'üü° Aten√ß√£o' if kpis.get('overall_score', 0) >= 60 else 'üî¥ Cr√≠tico'}
- **√öltima Atualiza√ß√£o**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
- **Pr√≥xima Coleta**: {(datetime.now() + timedelta(seconds=self.config['update_interval'])).strftime('%Y-%m-%d %H:%M:%S')}

---
*Relat√≥rio gerado automaticamente pelo Metrics Agent*
"""
            
            self.logger.info("‚úÖ Relat√≥rio de m√©tricas gerado com sucesso")
            return report
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao gerar relat√≥rio: {e}")
            return f"‚ùå Erro ao gerar relat√≥rio: {e}"
    
    def run(self):
        """Executa o agente de m√©tricas"""
        self.logger.info("üöÄ Iniciando Metrics Agent...")
        
        try:
            # Coletar m√©tricas
            system_metrics = self.collect_system_metrics()
            app_metrics = self.collect_application_metrics()
            
            # Calcular KPIs
            kpis = self.calculate_kpis(system_metrics, app_metrics)
            
            # Salvar m√©tricas
            self.save_metrics(system_metrics, self.config["metrics_file"])
            self.save_metrics(kpis, self.config["dashboard_file"])
            
            # Gerar relat√≥rio
            report = self.generate_metrics_report()
            
            # Salvar relat√≥rio
            report_file = self.metrics_path / "metrics_report.md"
            with open(report_file, 'w', encoding='utf-8') as f:
                f.write(report)
            
            self.logger.info("‚úÖ Metrics Agent executado com sucesso")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erro na execu√ß√£o do Metrics Agent: {e}")
            return False

def main():
    """Fun√ß√£o principal"""
    agent = MetricsAgent()
    success = agent.run()
    
    if success:
        print("‚úÖ Metrics Agent executado com sucesso")
        return 0
    else:
        print("‚ùå Erro na execu√ß√£o do Metrics Agent")
        return 1

if __name__ == "__main__":
    exit(main()) 

# Fun√ß√£o de integra√ß√£o com o m√≥dulo
def integrate_with_module():
    """Integra o script com o m√≥dulo de destino."""
    module = AgentorchestratorModule()
    return module.execute()

if __name__ == "__main__":
    # Executar integra√ß√£o com m√≥dulo
    result = integrate_with_module()
    if result:
        print(f"‚úÖ Script metrics_agent.py executado com sucesso via m√≥dulo agents.agent_orchestrator")
    else:
        print(f"‚ùå Erro na execu√ß√£o do script metrics_agent.py via m√≥dulo agents.agent_orchestrator")
