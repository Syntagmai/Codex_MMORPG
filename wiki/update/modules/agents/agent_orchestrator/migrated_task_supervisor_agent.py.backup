#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script Migrado: task_supervisor_agent.py
MÃ³dulo de Destino: agents.agent_orchestrator
Data de MigraÃ§Ã£o: 2025-08-01 12:21:44

Script original migrado para a estrutura modular unificada.
"""

# Imports do mÃ³dulo
from . import AgentorchestratorModule

# ConteÃºdo original do script
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Task Supervisor Agent - Gerenciador de Fluidez de Tarefas
========================================================

Agente supervisor que gerencia a fluidez das tarefas no Cursor IDE.
Monitora o progresso dos agentes e automaticamente continua para a prÃ³xima tarefa.

Autor: Sistema BMAD
VersÃ£o: 1.0.0
Data: 2025-08-01
"""

import os
import json
import sys
import time
import logging
import argparse
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import subprocess
import re

# Importar utilitÃ¡rio de caminhos absolutos
try:
    from absolute_path_utility import get_path, create_file_safely, log_message
except ImportError:
    def get_path(path_name: str):
        return None
    def create_file_safely(path_name: str, filename: str, content: str):
        return False
    def log_message(message: str, level: str = "INFO"):
        print(f"{level}: {message}")

class TaskSupervisorAgent:
    """
    Agente supervisor para gerenciar fluidez de tarefas no Cursor IDE.
    """
    
    def __init__(self):
        """
        Inicializa o Task Supervisor Agent.
        """
        # Configurar logging
        log_path = get_path('log')
        if log_path:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[
                    logging.FileHandler(log_path / "task_supervisor_agent.log"),
                    logging.StreamHandler()
                ]
            )
        self.logger = logging.getLogger(__name__)
        
        # ConfiguraÃ§Ãµes do supervisor
        self.task_master_path = "wiki/dashboard/task_master.md"
        self.last_command_time = None
        self.command_cooldown = 300  # 5 minutos em segundos
        self.response_timeout = 60   # 60 segundos
        self.monitoring_active = False
        
        # PadrÃµes para detectar conclusÃ£o de tarefas
        self.completion_patterns = [
            r"concluÃ­do|concluÃ­da|completo|completa",
            r"feito|feita|finalizado|finalizada",
            r"terminado|terminada|pronto|pronta",
            r"sucesso|success|completado|completada",
            r"âœ…|ğŸŸ¢|ğŸ¯|ğŸ†",
            r"task.*concluÃ­da|task.*completa",
            r"epic.*concluÃ­da|epic.*completa"
        ]
        
        # PadrÃµes para detectar espera por instruÃ§Ãµes
        self.waiting_patterns = [
            r"prÃ³xima.*tarefa|next.*task",
            r"aguardando.*instruÃ§Ã£o|waiting.*instruction",
            r"prÃ³ximo.*passo|next.*step",
            r"o que.*fazer|what.*to.*do",
            r"prÃ³xima.*aÃ§Ã£o|next.*action",
            r"continuar|continue"
        ]
        
        # PadrÃµes para detectar erros ou problemas
        self.error_patterns = [
            r"erro|error|falha|failure",
            r"problema|problem|issue",
            r"âŒ|ğŸ”´|âš ï¸|ğŸš¨",
            r"nÃ£o.*funciona|doesn't.*work",
            r"falhou|failed|broke"
        ]
        
        self.logger.info("Task Supervisor Agent inicializado")
    
    def read_task_master(self) -> Optional[str]:
        """
        LÃª o arquivo Task Master para anÃ¡lise.
        
        Returns:
            str: ConteÃºdo do Task Master ou None se erro
        """
        try:
            task_master_file = Path(self.task_master_path)
            if task_master_file.exists():
                with open(task_master_file, 'r', encoding='utf-8') as f:
                    return f.read()
            else:
                self.logger.error(f"Task Master nÃ£o encontrado: {self.task_master_path}")
                return None
        except Exception as e:
            self.logger.error(f"Erro ao ler Task Master: {e}")
            return None
    
    def extract_current_task(self, content: str) -> Optional[Dict]:
        """
        Extrai a tarefa atual do Task Master.
        
        Args:
            content: ConteÃºdo do Task Master
            
        Returns:
            Dict: InformaÃ§Ãµes da tarefa atual ou None
        """
        try:
            # Procurar por seÃ§Ã£o "PRÃ“XIMA TASK"
            next_task_match = re.search(
                r'## ğŸ¯ \*\*PRÃ“XIMA TASK.*?\*\*\n\n### \*\*ğŸ”¥ Task (\d+\.\d+) - ([^*]+)\*\*',
                content,
                re.DOTALL | re.IGNORECASE
            )
            
            if next_task_match:
                task_id = next_task_match.group(1)
                task_name = next_task_match.group(2).strip()
                
                # Procurar por detalhes da tarefa
                task_section = re.search(
                    rf'- \*\*Status\*\*: ([^\n]+)\n- \*\*Prioridade\*\*: ([^\n]+)\n- \*\*Agente\*\*: ([^\n]+)\n- \*\*Comando\*\*: ([^\n]+)',
                    content,
                    re.DOTALL
                )
                
                if task_section:
                    return {
                        'id': task_id,
                        'name': task_name,
                        'status': task_section.group(1).strip(),
                        'priority': task_section.group(2).strip(),
                        'agent': task_section.group(3).strip(),
                        'command': task_section.group(4).strip()
                    }
            
            return None
            
        except Exception as e:
            self.logger.error(f"Erro ao extrair tarefa atual: {e}")
            return None
    
    def check_task_completion(self, content: str) -> bool:
        """
        Verifica se hÃ¡ indicaÃ§Ãµes de conclusÃ£o de tarefa.
        
        Args:
            content: ConteÃºdo para anÃ¡lise
            
        Returns:
            bool: True se detectar conclusÃ£o
        """
        try:
            content_lower = content.lower()
            
            # Verificar padrÃµes de conclusÃ£o
            for pattern in self.completion_patterns:
                if re.search(pattern, content_lower):
                    self.logger.info(f"Detectado padrÃ£o de conclusÃ£o: {pattern}")
                    return True
            
            # Verificar se hÃ¡ muitas tarefas marcadas como completas
            completed_tasks = len(re.findall(r'âœ….*COMPLETA|âœ….*CONCLUÃDA', content))
            if completed_tasks > 0:
                self.logger.info(f"Detectadas {completed_tasks} tarefas completas")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar conclusÃ£o: {e}")
            return False
    
    def check_waiting_for_instructions(self, content: str) -> bool:
        """
        Verifica se estÃ¡ aguardando instruÃ§Ãµes.
        
        Args:
            content: ConteÃºdo para anÃ¡lise
            
        Returns:
            bool: True se detectar espera por instruÃ§Ãµes
        """
        try:
            content_lower = content.lower()
            
            # Verificar padrÃµes de espera
            for pattern in self.waiting_patterns:
                if re.search(pattern, content_lower):
                    self.logger.info(f"Detectado padrÃ£o de espera: {pattern}")
                    return True
            
            # Verificar se hÃ¡ perguntas no final
            if re.search(r'\?\s*$', content.strip()):
                self.logger.info("Detectada pergunta no final da mensagem")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar espera: {e}")
            return False
    
    def check_for_errors(self, content: str) -> bool:
        """
        Verifica se hÃ¡ erros ou problemas.
        
        Args:
            content: ConteÃºdo para anÃ¡lise
            
        Returns:
            bool: True se detectar erros
        """
        try:
            content_lower = content.lower()
            
            # Verificar padrÃµes de erro
            for pattern in self.error_patterns:
                if re.search(pattern, content_lower):
                    self.logger.warning(f"Detectado possÃ­vel erro: {pattern}")
                    return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar erros: {e}")
            return False
    
    def can_send_command(self) -> bool:
        """
        Verifica se pode enviar comando (respeitando cooldown).
        
        Returns:
            bool: True se pode enviar comando
        """
        if self.last_command_time is None:
            return True
        
        time_since_last = time.time() - self.last_command_time
        return time_since_last >= self.command_cooldown
    
    def generate_continue_command(self, current_task: Optional[Dict] = None) -> str:
        """
        Gera comando para continuar para a prÃ³xima tarefa.
        
        Args:
            current_task: InformaÃ§Ãµes da tarefa atual
            
        Returns:
            str: Comando para continuar
        """
        if current_task:
            return f"@cursor.md continue para a prÃ³xima tarefa pfv - Task {current_task['id']} {current_task['name']}"
        else:
            return "@cursor.md continue para a prÃ³xima tarefa pfv"
    
    def log_supervision_action(self, action: str, details: str = "") -> None:
        """
        Registra aÃ§Ã£o do supervisor.
        
        Args:
            action: Tipo de aÃ§Ã£o
            details: Detalhes adicionais
        """
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'details': details,
            'agent': 'TaskSupervisorAgent'
        }
        
        log_content = json.dumps(log_entry, indent=2, ensure_ascii=False)
        create_file_safely('log', 'task_supervisor_actions.json', log_content)
        
        self.logger.info(f"AÃ§Ã£o do supervisor: {action} - {details}")
    
    def analyze_conversation_context(self) -> Dict:
        """
        Analisa o contexto da conversaÃ§Ã£o atual.
        
        Returns:
            Dict: AnÃ¡lise do contexto
        """
        try:
            # Ler Task Master
            task_master_content = self.read_task_master()
            if not task_master_content:
                return {'error': 'NÃ£o foi possÃ­vel ler Task Master'}
            
            # Extrair tarefa atual
            current_task = self.extract_current_task(task_master_content)
            
            # Verificar conclusÃ£o
            completion_detected = self.check_task_completion(task_master_content)
            
            # Verificar espera por instruÃ§Ãµes
            waiting_detected = self.check_waiting_for_instructions(task_master_content)
            
            # Verificar erros
            errors_detected = self.check_for_errors(task_master_content)
            
            return {
                'current_task': current_task,
                'completion_detected': completion_detected,
                'waiting_detected': waiting_detected,
                'errors_detected': errors_detected,
                'can_send_command': self.can_send_command(),
                'time_since_last_command': time.time() - self.last_command_time if self.last_command_time else None
            }
            
        except Exception as e:
            self.logger.error(f"Erro ao analisar contexto: {e}")
            return {'error': str(e)}
    
    def should_continue_to_next_task(self, context: Dict) -> bool:
        """
        Decide se deve continuar para a prÃ³xima tarefa.
        
        Args:
            context: Contexto analisado
            
        Returns:
            bool: True se deve continuar
        """
        # Verificar se pode enviar comando
        if not context.get('can_send_command', False):
            return False
        
        # Verificar se hÃ¡ erros
        if context.get('errors_detected', False):
            self.logger.info("Erros detectados - nÃ£o continuando automaticamente")
            return False
        
        # Verificar conclusÃ£o ou espera
        completion = context.get('completion_detected', False)
        waiting = context.get('waiting_detected', False)
        
        if completion or waiting:
            self.logger.info(f"Continuando para prÃ³xima tarefa - ConclusÃ£o: {completion}, Espera: {waiting}")
            return True
        
        return False
    
    def execute_supervision_cycle(self) -> bool:
        """
        Executa um ciclo de supervisÃ£o.
        
        Returns:
            bool: True se aÃ§Ã£o foi tomada
        """
        try:
            self.logger.info("Iniciando ciclo de supervisÃ£o...")
            
            # Analisar contexto
            context = self.analyze_conversation_context()
            
            if 'error' in context:
                self.logger.error(f"Erro na anÃ¡lise: {context['error']}")
                return False
            
            # Decidir se deve continuar
            if self.should_continue_to_next_task(context):
                # Gerar comando
                command = self.generate_continue_command(context.get('current_task'))
                
                # Registrar aÃ§Ã£o
                self.log_supervision_action(
                    'continue_to_next_task',
                    f"Comando: {command}, Contexto: {context}"
                )
                
                # Atualizar timestamp
                self.last_command_time = time.time()
                
                # Exibir comando para o usuÃ¡rio
                print(f"\nğŸ¯ **COMANDO DO SUPERVISOR:**")
                print(f"```")
                print(f"{command}")
                print(f"```")
                print(f"\nğŸ“‹ **Contexto:**")
                print(f"- Tarefa atual: {context.get('current_task', {}).get('id', 'N/A')}")
                print(f"- ConclusÃ£o detectada: {context.get('completion_detected', False)}")
                print(f"- Espera detectada: {context.get('waiting_detected', False)}")
                print(f"- Erros detectados: {context.get('errors_detected', False)}")
                
                return True
            
            else:
                self.logger.info("Nenhuma aÃ§Ã£o necessÃ¡ria neste ciclo")
                return False
                
        except Exception as e:
            self.logger.error(f"Erro no ciclo de supervisÃ£o: {e}")
            return False
    
    def start_monitoring(self, interval: int = 30) -> None:
        """
        Inicia monitoramento contÃ­nuo.
        
        Args:
            interval: Intervalo entre verificaÃ§Ãµes em segundos
        """
        try:
            self.logger.info(f"Iniciando monitoramento com intervalo de {interval}s")
            self.monitoring_active = True
            
            while self.monitoring_active:
                try:
                    # Executar ciclo de supervisÃ£o
                    action_taken = self.execute_supervision_cycle()
                    
                    if action_taken:
                        self.logger.info("AÃ§Ã£o tomada pelo supervisor")
                    
                    # Aguardar prÃ³ximo ciclo
                    time.sleep(interval)
                    
                except KeyboardInterrupt:
                    self.logger.info("Monitoramento interrompido pelo usuÃ¡rio")
                    break
                except Exception as e:
                    self.logger.error(f"Erro no ciclo de monitoramento: {e}")
                    time.sleep(interval)
            
            self.logger.info("Monitoramento finalizado")
            
        except Exception as e:
            self.logger.error(f"Erro ao iniciar monitoramento: {e}")
    
    def stop_monitoring(self) -> None:
        """
        Para o monitoramento.
        """
        self.monitoring_active = False
        self.logger.info("SolicitaÃ§Ã£o para parar monitoramento")
    
    def generate_supervision_report(self) -> str:
        """
        Gera relatÃ³rio de supervisÃ£o.
        
        Returns:
            str: ConteÃºdo do relatÃ³rio
        """
        try:
            context = self.analyze_conversation_context()
            
            report = f"""---
tags: [supervision, task_management, bmad]
type: supervision_report
status: active
created: {datetime.now().isoformat()}
---

# ğŸ“Š RelatÃ³rio de SupervisÃ£o - Task Supervisor Agent

## ğŸ¯ **Status Atual**

### **Monitoramento:**
- **Ativo**: {self.monitoring_active}
- **Ãšltimo comando**: {self.last_command_time or 'Nunca'}
- **Cooldown**: {self.command_cooldown}s
- **Timeout de resposta**: {self.response_timeout}s

        ### **AnÃ¡lise do Contexto:**
        - **Tarefa atual**: {context.get('current_task', {}).get('id', 'N/A') if context.get('current_task') else 'N/A'} - {context.get('current_task', {}).get('name', 'N/A') if context.get('current_task') else 'N/A'}
        - **ConclusÃ£o detectada**: {context.get('completion_detected', False)}
        - **Espera detectada**: {context.get('waiting_detected', False)}
        - **Erros detectados**: {context.get('errors_detected', False)}
        - **Pode enviar comando**: {context.get('can_send_command', False)}

## ğŸ“‹ **PadrÃµes de DetecÃ§Ã£o**

### **ConclusÃ£o:**
{chr(10).join(f"- {pattern}" for pattern in self.completion_patterns)}

### **Espera por InstruÃ§Ãµes:**
{chr(10).join(f"- {pattern}" for pattern in self.waiting_patterns)}

### **Erros:**
{chr(10).join(f"- {pattern}" for pattern in self.error_patterns)}

## ğŸš€ **PrÃ³ximas AÃ§Ãµes**

### **Se conclusÃ£o detectada:**
- Continuar automaticamente para prÃ³xima tarefa
- Gerar comando: `@cursor.md continue para a prÃ³xima tarefa pfv`

### **Se espera detectada:**
- Continuar automaticamente para prÃ³xima tarefa
- Gerar comando: `@cursor.md continue para a prÃ³xima tarefa pfv`

### **Se erros detectados:**
- NÃ£o continuar automaticamente
- Aguardar intervenÃ§Ã£o manual

## ğŸ“ˆ **EstatÃ­sticas**

- **Ciclos executados**: {self.last_command_time is not None}
- **Comandos enviados**: {1 if self.last_command_time else 0}
- **Tempo desde Ãºltimo comando**: {time.time() - self.last_command_time if self.last_command_time else 'N/A'}s

---

**RelatÃ³rio Gerado**: {datetime.now().isoformat()}  
**ResponsÃ¡vel**: Task Supervisor Agent  
**Status**: {'ğŸŸ¢ Ativo' if self.monitoring_active else 'ğŸ”´ Inativo'}
"""
            
            return report
            
        except Exception as e:
            self.logger.error(f"Erro ao gerar relatÃ³rio: {e}")
            return f"Erro ao gerar relatÃ³rio: {e}"

def main():
    """
    FunÃ§Ã£o principal para execuÃ§Ã£o do Task Supervisor Agent.
    """
    parser = argparse.ArgumentParser(description='Task Supervisor Agent - Gerenciador de Fluidez de Tarefas')
    parser.add_argument('--monitor', action='store_true', help='Iniciar monitoramento contÃ­nuo')
    parser.add_argument('--interval', type=int, default=30, help='Intervalo entre verificaÃ§Ãµes (segundos)')
    parser.add_argument('--analyze', action='store_true', help='Analisar contexto atual')
    parser.add_argument('--report', action='store_true', help='Gerar relatÃ³rio de supervisÃ£o')
    parser.add_argument('--test', action='store_true', help='Executar teste de detecÃ§Ã£o')
    
    args = parser.parse_args()
    
    print("ğŸ¯ Task Supervisor Agent - Gerenciador de Fluidez de Tarefas")
    print("=" * 60)
    
    # Inicializar agente
    agent = TaskSupervisorAgent()
    
    if args.analyze:
        print("ğŸ“Š Analisando contexto atual...")
        context = agent.analyze_conversation_context()
        print(f"Contexto: {json.dumps(context, indent=2, ensure_ascii=False)}")
        
    elif args.report:
        print("ğŸ“‹ Gerando relatÃ³rio de supervisÃ£o...")
        report = agent.generate_supervision_report()
        success = create_file_safely('log', 'task_supervisor_report.md', report)
        if success:
            print("âœ… RelatÃ³rio gerado: wiki/log/task_supervisor_report.md")
        else:
            print("âŒ Erro ao gerar relatÃ³rio")
            
    elif args.test:
        print("ğŸ§ª Executando teste de detecÃ§Ã£o...")
        # Testar com conteÃºdo de exemplo
        test_content = """
        âœ… Task 6.1 CONCLUÃDA - Professor Agent Ativado
        
        A task foi finalizada com sucesso.
        
        PrÃ³xima tarefa: Task 6.2
        """
        
        completion = agent.check_task_completion(test_content)
        waiting = agent.check_waiting_for_instructions(test_content)
        errors = agent.check_for_errors(test_content)
        
        print(f"Teste de detecÃ§Ã£o:")
        print(f"- ConclusÃ£o: {completion}")
        print(f"- Espera: {waiting}")
        print(f"- Erros: {errors}")
        
    elif args.monitor:
        print(f"ğŸ”„ Iniciando monitoramento com intervalo de {args.interval}s...")
        print("Pressione Ctrl+C para parar")
        agent.start_monitoring(args.interval)
        
    else:
        print("ğŸ“Š Executando anÃ¡lise Ãºnica...")
        context = agent.analyze_conversation_context()
        
        if 'error' in context:
            print(f"âŒ Erro: {context['error']}")
            sys.exit(1)
        
        print(f"ğŸ“‹ AnÃ¡lise do contexto:")
        current_task = context.get('current_task', {})
        print(f"- Tarefa atual: {current_task.get('id', 'N/A') if current_task else 'N/A'}")
        print(f"- ConclusÃ£o detectada: {context.get('completion_detected', False)}")
        print(f"- Espera detectada: {context.get('waiting_detected', False)}")
        print(f"- Erros detectados: {context.get('errors_detected', False)}")
        print(f"- Pode enviar comando: {context.get('can_send_command', False)}")
        
        if agent.should_continue_to_next_task(context):
            command = agent.generate_continue_command(context.get('current_task'))
            print(f"\nğŸ¯ **COMANDO RECOMENDADO:**")
            print(f"```")
            print(f"{command}")
            print(f"```")
        else:
            print("\nâœ… Nenhuma aÃ§Ã£o necessÃ¡ria no momento")

if __name__ == "__main__":
    main() 

# === INTEGRATED FROM start_task_supervisor.py ===
def main():
    """
    FunÃ§Ã£o principal para iniciar o Task Supervisor Agent.
    """
    print("ğŸ¯ Iniciando Task Supervisor Agent...")
    print("=" * 50)

# FunÃ§Ã£o de integraÃ§Ã£o com o mÃ³dulo
def integrate_with_module():
    """Integra o script com o mÃ³dulo de destino."""
    module = AgentorchestratorModule()
    return module.execute()

if __name__ == "__main__":
    # Executar integraÃ§Ã£o com mÃ³dulo
    result = integrate_with_module()
    if result:
        print(f"âœ… Script task_supervisor_agent.py executado com sucesso via mÃ³dulo agents.agent_orchestrator")
    else:
        print(f"âŒ Erro na execuÃ§Ã£o do script task_supervisor_agent.py via mÃ³dulo agents.agent_orchestrator")
