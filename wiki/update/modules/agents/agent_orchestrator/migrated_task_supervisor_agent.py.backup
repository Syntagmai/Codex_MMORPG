#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script Migrado: task_supervisor_agent.py
M√≥dulo de Destino: agents.agent_orchestrator
Data de Migra√ß√£o: 2025-08-01 12:21:44

Script original migrado para a estrutura modular unificada.
"""

# Imports do m√≥dulo
from . import AgentorchestratorModule

# Conte√∫do original do script
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Task Supervisor Agent - Gerenciador de Fluidez de Tarefas
========================================================

Agente supervisor que gerencia a fluidez das tarefas no Cursor IDE.
Monitora o progresso dos agentes e automaticamente continua para a pr√≥xima tarefa.

Autor: Sistema BMAD
Vers√£o: 1.0.0
Data: 2025-08-01
"""

import os
import json
import sys
import time
import logging
import argparse
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import subprocess
import re

# Importar utilit√°rio de caminhos absolutos
try:
    from absolute_path_utility import get_path, create_file_safely, log_message
except ImportError:
    def get_path(path_name: str):
        return None
    def create_file_safely(path_name: str, filename: str, content: str):
        return False
    def log_message(message: str, level: str = "INFO"):
        print(f"{level}: {message}")

class TaskSupervisorAgent:
    """
    Agente supervisor para gerenciar fluidez de tarefas no Cursor IDE.
    """
    
    def __init__(self):
        """
        Inicializa o Task Supervisor Agent.
        """
        # Configurar logging
        log_path = get_path('log')
        if log_path:
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[
                    logging.FileHandler(log_path / "task_supervisor_agent.log"),
                    logging.StreamHandler()
                ]
            )
        self.logger = logging.getLogger(__name__)
        
        # Configura√ß√µes do supervisor
        self.task_master_path = "wiki/dashboard/task_master.md"
        self.last_command_time = None
        self.command_cooldown = 300  # 5 minutos em segundos
        self.response_timeout = 60   # 60 segundos
        self.monitoring_active = False
        
        # Padr√µes para detectar conclus√£o de tarefas
        self.completion_patterns = [
            r"conclu√≠do|conclu√≠da|completo|completa",
            r"feito|feita|finalizado|finalizada",
            r"terminado|terminada|pronto|pronta",
            r"sucesso|success|completado|completada",
            r"‚úÖ|üü¢|üéØ|üèÜ",
            r"task.*conclu√≠da|task.*completa",
            r"epic.*conclu√≠da|epic.*completa"
        ]
        
        # Padr√µes para detectar espera por instru√ß√µes
        self.waiting_patterns = [
            r"pr√≥xima.*tarefa|next.*task",
            r"aguardando.*instru√ß√£o|waiting.*instruction",
            r"pr√≥ximo.*passo|next.*step",
            r"o que.*fazer|what.*to.*do",
            r"pr√≥xima.*a√ß√£o|next.*action",
            r"continuar|continue"
        ]
        
        # Padr√µes para detectar erros ou problemas
        self.error_patterns = [
            r"erro|error|falha|failure",
            r"problema|problem|issue",
            r"‚ùå|üî¥|‚ö†Ô∏è|üö®",
            r"n√£o.*funciona|doesn't.*work",
            r"falhou|failed|broke"
        ]
        
        self.logger.info("Task Supervisor Agent inicializado")
    
    def read_task_master(self) -> Optional[str]:
        """
        L√™ o arquivo Task Master para an√°lise.
        
        Returns:
            str: Conte√∫do do Task Master ou None se erro
        """
        try:
            task_master_file = Path(self.task_master_path)
            if task_master_file.exists():
                with open(task_master_file, 'r', encoding='utf-8') as f:
                    return f.read()
            else:
                self.logger.error(f"Task Master n√£o encontrado: {self.task_master_path}")
                return None
        except Exception as e:
            self.logger.error(f"Erro ao ler Task Master: {e}")
            return None
    
    def extract_current_task(self, content: str) -> Optional[Dict]:
        """
        Extrai a tarefa atual do Task Master.
        
        Args:
            content: Conte√∫do do Task Master
            
        Returns:
            Dict: Informa√ß√µes da tarefa atual ou None
        """
        try:
            # Procurar por se√ß√£o "PR√ìXIMA TASK"
            next_task_match = re.search(
                r'## üéØ \*\*PR√ìXIMA TASK.*?\*\*\n\n### \*\*üî• Task (\d+\.\d+) - ([^*]+)\*\*',
                content,
                re.DOTALL | re.IGNORECASE
            )
            
            if next_task_match:
                task_id = next_task_match.group(1)
                task_name = next_task_match.group(2).strip()
                
                # Procurar por detalhes da tarefa
                task_section = re.search(
                    rf'- \*\*Status\*\*: ([^\n]+)\n- \*\*Prioridade\*\*: ([^\n]+)\n- \*\*Agente\*\*: ([^\n]+)\n- \*\*Comando\*\*: ([^\n]+)',
                    content,
                    re.DOTALL
                )
                
                if task_section:
                    return {
                        'id': task_id,
                        'name': task_name,
                        'status': task_section.group(1).strip(),
                        'priority': task_section.group(2).strip(),
                        'agent': task_section.group(3).strip(),
                        'command': task_section.group(4).strip()
                    }
            
            return None
            
        except Exception as e:
            self.logger.error(f"Erro ao extrair tarefa atual: {e}")
            return None
    
    def check_task_completion(self, content: str) -> bool:
        """
        Verifica se h√° indica√ß√µes de conclus√£o de tarefa.
        
        Args:
            content: Conte√∫do para an√°lise
            
        Returns:
            bool: True se detectar conclus√£o
        """
        try:
            content_lower = content.lower()
            
            # Verificar padr√µes de conclus√£o
            for pattern in self.completion_patterns:
                if re.search(pattern, content_lower):
                    self.logger.info(f"Detectado padr√£o de conclus√£o: {pattern}")
                    return True
            
            # Verificar se h√° muitas tarefas marcadas como completas
            completed_tasks = len(re.findall(r'‚úÖ.*COMPLETA|‚úÖ.*CONCLU√çDA', content))
            if completed_tasks > 0:
                self.logger.info(f"Detectadas {completed_tasks} tarefas completas")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar conclus√£o: {e}")
            return False
    
    def check_waiting_for_instructions(self, content: str) -> bool:
        """
        Verifica se est√° aguardando instru√ß√µes.
        
        Args:
            content: Conte√∫do para an√°lise
            
        Returns:
            bool: True se detectar espera por instru√ß√µes
        """
        try:
            content_lower = content.lower()
            
            # Verificar padr√µes de espera
            for pattern in self.waiting_patterns:
                if re.search(pattern, content_lower):
                    self.logger.info(f"Detectado padr√£o de espera: {pattern}")
                    return True
            
            # Verificar se h√° perguntas no final
            if re.search(r'\?\s*$', content.strip()):
                self.logger.info("Detectada pergunta no final da mensagem")
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar espera: {e}")
            return False
    
    def check_for_errors(self, content: str) -> bool:
        """
        Verifica se h√° erros ou problemas.
        
        Args:
            content: Conte√∫do para an√°lise
            
        Returns:
            bool: True se detectar erros
        """
        try:
            content_lower = content.lower()
            
            # Verificar padr√µes de erro
            for pattern in self.error_patterns:
                if re.search(pattern, content_lower):
                    self.logger.warning(f"Detectado poss√≠vel erro: {pattern}")
                    return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"Erro ao verificar erros: {e}")
            return False
    
    def can_send_command(self) -> bool:
        """
        Verifica se pode enviar comando (respeitando cooldown).
        
        Returns:
            bool: True se pode enviar comando
        """
        if self.last_command_time is None:
            return True
        
        time_since_last = time.time() - self.last_command_time
        return time_since_last >= self.command_cooldown
    
    def generate_continue_command(self, current_task: Optional[Dict] = None) -> str:
        """
        Gera comando para continuar para a pr√≥xima tarefa.
        
        Args:
            current_task: Informa√ß√µes da tarefa atual
            
        Returns:
            str: Comando para continuar
        """
        if current_task:
            return f"@cursor.md continue para a pr√≥xima tarefa pfv - Task {current_task['id']} {current_task['name']}"
        else:
            return "@cursor.md continue para a pr√≥xima tarefa pfv"
    
    def log_supervision_action(self, action: str, details: str = "") -> None:
        """
        Registra a√ß√£o do supervisor.
        
        Args:
            action: Tipo de a√ß√£o
            details: Detalhes adicionais
        """
        log_entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'details': details,
            'agent': 'TaskSupervisorAgent'
        }
        
        log_content = json.dumps(log_entry, indent=2, ensure_ascii=False)
        create_file_safely('log', 'task_supervisor_actions.json', log_content)
        
        self.logger.info(f"A√ß√£o do supervisor: {action} - {details}")
    
    def analyze_conversation_context(self) -> Dict:
        """
        Analisa o contexto da conversa√ß√£o atual.
        
        Returns:
            Dict: An√°lise do contexto
        """
        try:
            # Ler Task Master
            task_master_content = self.read_task_master()
            if not task_master_content:
                return {'error': 'N√£o foi poss√≠vel ler Task Master'}
            
            # Extrair tarefa atual
            current_task = self.extract_current_task(task_master_content)
            
            # Verificar conclus√£o
            completion_detected = self.check_task_completion(task_master_content)
            
            # Verificar espera por instru√ß√µes
            waiting_detected = self.check_waiting_for_instructions(task_master_content)
            
            # Verificar erros
            errors_detected = self.check_for_errors(task_master_content)
            
            return {
                'current_task': current_task,
                'completion_detected': completion_detected,
                'waiting_detected': waiting_detected,
                'errors_detected': errors_detected,
                'can_send_command': self.can_send_command(),
                'time_since_last_command': time.time() - self.last_command_time if self.last_command_time else None
            }
            
        except Exception as e:
            self.logger.error(f"Erro ao analisar contexto: {e}")
            return {'error': str(e)}
    
    def should_continue_to_next_task(self, context: Dict) -> bool:
        """
        Decide se deve continuar para a pr√≥xima tarefa.
        
        Args:
            context: Contexto analisado
            
        Returns:
            bool: True se deve continuar
        """
        # Verificar se pode enviar comando
        if not context.get('can_send_command', False):
            return False
        
        # Verificar se h√° erros
        if context.get('errors_detected', False):
            self.logger.info("Erros detectados - n√£o continuando automaticamente")
            return False
        
        # Verificar conclus√£o ou espera
        completion = context.get('completion_detected', False)
        waiting = context.get('waiting_detected', False)
        
        if completion or waiting:
            self.logger.info(f"Continuando para pr√≥xima tarefa - Conclus√£o: {completion}, Espera: {waiting}")
            return True
        
        return False
    
    def execute_supervision_cycle(self) -> bool:
        """
        Executa um ciclo de supervis√£o.
        
        Returns:
            bool: True se a√ß√£o foi tomada
        """
        try:
            self.logger.info("Iniciando ciclo de supervis√£o...")
            
            # Analisar contexto
            context = self.analyze_conversation_context()
            
            if 'error' in context:
                self.logger.error(f"Erro na an√°lise: {context['error']}")
                return False
            
            # Decidir se deve continuar
            if self.should_continue_to_next_task(context):
                # Gerar comando
                command = self.generate_continue_command(context.get('current_task'))
                
                # Registrar a√ß√£o
                self.log_supervision_action(
                    'continue_to_next_task',
                    f"Comando: {command}, Contexto: {context}"
                )
                
                # Atualizar timestamp
                self.last_command_time = time.time()
                
                # Exibir comando para o usu√°rio
                print(f"\nüéØ **COMANDO DO SUPERVISOR:**")
                print(f"```")
                print(f"{command}")
                print(f"```")
                print(f"\nüìã **Contexto:**")
                print(f"- Tarefa atual: {context.get('current_task', {}).get('id', 'N/A')}")
                print(f"- Conclus√£o detectada: {context.get('completion_detected', False)}")
                print(f"- Espera detectada: {context.get('waiting_detected', False)}")
                print(f"- Erros detectados: {context.get('errors_detected', False)}")
                
                return True
            
            else:
                self.logger.info("Nenhuma a√ß√£o necess√°ria neste ciclo")
                return False
                
        except Exception as e:
            self.logger.error(f"Erro no ciclo de supervis√£o: {e}")
            return False
    
    def start_monitoring(self, interval: int = 30) -> None:
        """
        Inicia monitoramento cont√≠nuo.
        
        Args:
            interval: Intervalo entre verifica√ß√µes em segundos
        """
        try:
            self.logger.info(f"Iniciando monitoramento com intervalo de {interval}s")
            self.monitoring_active = True
            
            while self.monitoring_active:
                try:
                    # Executar ciclo de supervis√£o
                    action_taken = self.execute_supervision_cycle()
                    
                    if action_taken:
                        self.logger.info("A√ß√£o tomada pelo supervisor")
                    
                    # Aguardar pr√≥ximo ciclo
                    time.sleep(interval)
                    
                except KeyboardInterrupt:
                    self.logger.info("Monitoramento interrompido pelo usu√°rio")
                    break
                except Exception as e:
                    self.logger.error(f"Erro no ciclo de monitoramento: {e}")
                    time.sleep(interval)
            
            self.logger.info("Monitoramento finalizado")
            
        except Exception as e:
            self.logger.error(f"Erro ao iniciar monitoramento: {e}")
    
    def stop_monitoring(self) -> None:
        """
        Para o monitoramento.
        """
        self.monitoring_active = False
        self.logger.info("Solicita√ß√£o para parar monitoramento")
    
    def generate_supervision_report(self) -> str:
        """
        Gera relat√≥rio de supervis√£o.
        
        Returns:
            str: Conte√∫do do relat√≥rio
        """
        try:
            context = self.analyze_conversation_context()
            
            report = f"""---
tags: [supervision, task_management, bmad]
type: supervision_report
status: active
created: {datetime.now().isoformat()}
---

# üìä Relat√≥rio de Supervis√£o - Task Supervisor Agent

## üéØ **Status Atual**

### **Monitoramento:**
- **Ativo**: {self.monitoring_active}
- **√öltimo comando**: {self.last_command_time or 'Nunca'}
- **Cooldown**: {self.command_cooldown}s
- **Timeout de resposta**: {self.response_timeout}s

        ### **An√°lise do Contexto:**
        - **Tarefa atual**: {context.get('current_task', {}).get('id', 'N/A') if context.get('current_task') else 'N/A'} - {context.get('current_task', {}).get('name', 'N/A') if context.get('current_task') else 'N/A'}
        - **Conclus√£o detectada**: {context.get('completion_detected', False)}
        - **Espera detectada**: {context.get('waiting_detected', False)}
        - **Erros detectados**: {context.get('errors_detected', False)}
        - **Pode enviar comando**: {context.get('can_send_command', False)}

## üìã **Padr√µes de Detec√ß√£o**

### **Conclus√£o:**
{chr(10).join(f"- {pattern}" for pattern in self.completion_patterns)}

### **Espera por Instru√ß√µes:**
{chr(10).join(f"- {pattern}" for pattern in self.waiting_patterns)}

### **Erros:**
{chr(10).join(f"- {pattern}" for pattern in self.error_patterns)}

## üöÄ **Pr√≥ximas A√ß√µes**

### **Se conclus√£o detectada:**
- Continuar automaticamente para pr√≥xima tarefa
- Gerar comando: `@cursor.md continue para a pr√≥xima tarefa pfv`

### **Se espera detectada:**
- Continuar automaticamente para pr√≥xima tarefa
- Gerar comando: `@cursor.md continue para a pr√≥xima tarefa pfv`

### **Se erros detectados:**
- N√£o continuar automaticamente
- Aguardar interven√ß√£o manual

## üìà **Estat√≠sticas**

- **Ciclos executados**: {self.last_command_time is not None}
- **Comandos enviados**: {1 if self.last_command_time else 0}
- **Tempo desde √∫ltimo comando**: {time.time() - self.last_command_time if self.last_command_time else 'N/A'}s

---

**Relat√≥rio Gerado**: {datetime.now().isoformat()}  
**Respons√°vel**: Task Supervisor Agent  
**Status**: {'üü¢ Ativo' if self.monitoring_active else 'üî¥ Inativo'}
"""
            
            return report
            
        except Exception as e:
            self.logger.error(f"Erro ao gerar relat√≥rio: {e}")
            return f"Erro ao gerar relat√≥rio: {e}"

def main():
    """
    Fun√ß√£o principal para execu√ß√£o do Task Supervisor Agent.
    """
    parser = argparse.ArgumentParser(description='Task Supervisor Agent - Gerenciador de Fluidez de Tarefas')
    parser.add_argument('--monitor', action='store_true', help='Iniciar monitoramento cont√≠nuo')
    parser.add_argument('--interval', type=int, default=30, help='Intervalo entre verifica√ß√µes (segundos)')
    parser.add_argument('--analyze', action='store_true', help='Analisar contexto atual')
    parser.add_argument('--report', action='store_true', help='Gerar relat√≥rio de supervis√£o')
    parser.add_argument('--test', action='store_true', help='Executar teste de detec√ß√£o')
    
    args = parser.parse_args()
    
    print("üéØ Task Supervisor Agent - Gerenciador de Fluidez de Tarefas")
    print("=" * 60)
    
    # Inicializar agente
    agent = TaskSupervisorAgent()
    
    if args.analyze:
        print("üìä Analisando contexto atual...")
        context = agent.analyze_conversation_context()
        print(f"Contexto: {json.dumps(context, indent=2, ensure_ascii=False)}")
        
    elif args.report:
        print("üìã Gerando relat√≥rio de supervis√£o...")
        report = agent.generate_supervision_report()
        success = create_file_safely('log', 'task_supervisor_report.md', report)
        if success:
            print("‚úÖ Relat√≥rio gerado: wiki/log/task_supervisor_report.md")
        else:
            print("‚ùå Erro ao gerar relat√≥rio")
            
    elif args.test:
        print("üß™ Executando teste de detec√ß√£o...")
        # Testar com conte√∫do de exemplo
        test_content = """
        ‚úÖ Task 6.1 CONCLU√çDA - Professor Agent Ativado
        
        A task foi finalizada com sucesso.
        
        Pr√≥xima tarefa: Task 6.2
        """
        
        completion = agent.check_task_completion(test_content)
        waiting = agent.check_waiting_for_instructions(test_content)
        errors = agent.check_for_errors(test_content)
        
        print(f"Teste de detec√ß√£o:")
        print(f"- Conclus√£o: {completion}")
        print(f"- Espera: {waiting}")
        print(f"- Erros: {errors}")
        
    elif args.monitor:
        print(f"üîÑ Iniciando monitoramento com intervalo de {args.interval}s...")
        print("Pressione Ctrl+C para parar")
        agent.start_monitoring(args.interval)
        
    else:
        print("üìä Executando an√°lise √∫nica...")
        context = agent.analyze_conversation_context()
        
        if 'error' in context:
            print(f"‚ùå Erro: {context['error']}")
            sys.exit(1)
        
        print(f"üìã An√°lise do contexto:")
        current_task = context.get('current_task', {})
        print(f"- Tarefa atual: {current_task.get('id', 'N/A') if current_task else 'N/A'}")
        print(f"- Conclus√£o detectada: {context.get('completion_detected', False)}")
        print(f"- Espera detectada: {context.get('waiting_detected', False)}")
        print(f"- Erros detectados: {context.get('errors_detected', False)}")
        print(f"- Pode enviar comando: {context.get('can_send_command', False)}")
        
        if agent.should_continue_to_next_task(context):
            command = agent.generate_continue_command(context.get('current_task'))
            print(f"\nüéØ **COMANDO RECOMENDADO:**")
            print(f"```")
            print(f"{command}")
            print(f"```")
        else:
            print("\n‚úÖ Nenhuma a√ß√£o necess√°ria no momento")

if __name__ == "__main__":
    main() 

# === INTEGRATED FROM start_task_supervisor.py ===
def main():
    """
    Fun√ß√£o principal para iniciar o Task Supervisor Agent.
    """
    print("üéØ Iniciando Task Supervisor Agent...")
    print("=" * 50)

# Fun√ß√£o de integra√ß√£o com o m√≥dulo
def integrate_with_module():
    """Integra o script com o m√≥dulo de destino."""
    module = AgentorchestratorModule()
    return module.execute()

if __name__ == "__main__":
    # Executar integra√ß√£o com m√≥dulo
    result = integrate_with_module()
    if result:
        print(f"‚úÖ Script task_supervisor_agent.py executado com sucesso via m√≥dulo agents.agent_orchestrator")
    else:
        print(f"‚ùå Erro na execu√ß√£o do script task_supervisor_agent.py via m√≥dulo agents.agent_orchestrator")
