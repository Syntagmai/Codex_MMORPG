---
tags: [integration, error_handling, debugging, reliability, fault_tolerance, educational, module]
aliases: [tratamento_erros, error_handling, debugging, fault_tolerance]
type: educational_module
status: active
priority: high
level: intermediate
created: 2025-08-05
updated: 2025-08-05
module: 4.3
course: integration
prerequisites: [4.2_sincronizacao_dados, 2.7_sistemas_avancados]
next_module: 4.4_estrategias_teste
---

# ‚ö†Ô∏è **M√≥dulo 4.3: Tratamento de Erros**

## üéØ **Vis√£o Geral**

Este m√≥dulo explora estrat√©gias robustas de tratamento de erros para sistemas distribu√≠dos entre OTClient e Canary, baseado na an√°lise de migra√ß√£o e guias pr√°ticos. Voc√™ aprender√° como implementar sistemas resilientes, detectar e recuperar de falhas, e criar mecanismos de fallback eficientes.

## üìö **Objetivos de Aprendizado**

### **üéØ Ao final deste m√≥dulo, voc√™ ser√° capaz de:**
- ‚úÖ Implementar estrat√©gias robustas de tratamento de erros
- ‚úÖ Criar sistemas de detec√ß√£o e recupera√ß√£o de falhas
- ‚úÖ Implementar mecanismos de retry e circuit breaker
- ‚úÖ Desenvolver logging e monitoramento de erros
- ‚úÖ Criar estrat√©gias de fallback e degrada√ß√£o graciosa

## ‚ö†Ô∏è **Conte√∫do do M√≥dulo**

### **üìñ 1. Fundamentos de Tratamento de Erros**

#### **üö® Tipos de Erros**
```cpp
// Categoriza√ß√£o de erros
enum ErrorCategory {
    ERROR_NETWORK,      // Erros de rede
    ERROR_DATABASE,     // Erros de banco de dados
    ERROR_VALIDATION,   // Erros de valida√ß√£o
    ERROR_AUTHENTICATION, // Erros de autentica√ß√£o
    ERROR_PERMISSION,   // Erros de permiss√£o
    ERROR_TIMEOUT,      // Erros de timeout
    ERROR_RESOURCE,     // Erros de recursos
    ERROR_LOGIC,        // Erros de l√≥gica
    ERROR_UNKNOWN       // Erros desconhecidos
};

// Estrutura de erro padronizada
struct ErrorInfo {
    ErrorCategory category;
    std::string code;
    std::string message;
    std::string details;
    uint64_t timestamp;
    std::string stackTrace;
    std::map<std::string, std::string> context;
};
```

#### **üîÑ Estrat√©gias de Tratamento**
```cpp
// Estrat√©gias de tratamento de erros
enum ErrorStrategy {
    STRATEGY_RETRY,     // Tentar novamente
    STRATEGY_FALLBACK,  // Usar alternativa
    STRATEGY_CIRCUIT_BREAKER, // Abrir circuito
    STRATEGY_DEGRADE,   // Degradar funcionalidade
    STRATEGY_ABORT,     // Abortar opera√ß√£o
    STRATEGY_LOG        // Apenas logar
};

// Sistema de tratamento de erros
class ErrorHandler {
private:
    std::map<ErrorCategory, ErrorStrategy> strategies;
    std::vector<ErrorInfo> errorLog;
    
public:
    ErrorHandler() {
        // Configura estrat√©gias padr√£o
        strategies[ERROR_NETWORK] = STRATEGY_RETRY;
        strategies[ERROR_DATABASE] = STRATEGY_RETRY;
        strategies[ERROR_VALIDATION] = STRATEGY_ABORT;
        strategies[ERROR_AUTHENTICATION] = STRATEGY_ABORT;
        strategies[ERROR_PERMISSION] = STRATEGY_ABORT;
        strategies[ERROR_TIMEOUT] = STRATEGY_RETRY;
        strategies[ERROR_RESOURCE] = STRATEGY_FALLBACK;
        strategies[ERROR_LOGIC] = STRATEGY_LOG;
        strategies[ERROR_UNKNOWN] = STRATEGY_LOG;
    }
    
    void handleError(const ErrorInfo& error) {
        errorLog.push_back(error);
        
        auto strategy = strategies.find(error.category);
        if (strategy == strategies.end()) {
            strategy = strategies.find(ERROR_UNKNOWN);
        }
        
        switch (strategy->second) {
            case STRATEGY_RETRY:
                handleRetry(error);
                break;
            case STRATEGY_FALLBACK:
                handleFallback(error);
                break;
            case STRATEGY_CIRCUIT_BREAKER:
                handleCircuitBreaker(error);
                break;
            case STRATEGY_DEGRADE:
                handleDegrade(error);
                break;
            case STRATEGY_ABORT:
                handleAbort(error);
                break;
            case STRATEGY_LOG:
                handleLog(error);
                break;
        }
    }
    
private:
    void handleRetry(const ErrorInfo& error) {
        // Implementa√ß√£o de retry
    }
    
    void handleFallback(const ErrorInfo& error) {
        // Implementa√ß√£o de fallback
    }
    
    void handleCircuitBreaker(const ErrorInfo& error) {
        // Implementa√ß√£o de circuit breaker
    }
    
    void handleDegrade(const ErrorInfo& error) {
        // Implementa√ß√£o de degrada√ß√£o
    }
    
    void handleAbort(const ErrorInfo& error) {
        // Implementa√ß√£o de abort
    }
    
    void handleLog(const ErrorInfo& error) {
        // Implementa√ß√£o de logging
    }
};
```

### **üìñ 2. Sistema de Retry Inteligente**

#### **üîÑ Retry com Backoff Exponencial**
```cpp
// Sistema de retry com backoff exponencial
class RetryManager {
private:
    struct RetryConfig {
        uint32_t maxAttempts;
        uint32_t initialDelay;
        uint32_t maxDelay;
        double backoffMultiplier;
        std::vector<ErrorCategory> retryableErrors;
    };
    
    RetryConfig config;
    std::map<std::string, uint32_t> attemptCounts;
    
public:
    RetryManager() {
        config.maxAttempts = 3;
        config.initialDelay = 1000; // 1 segundo
        config.maxDelay = 30000;    // 30 segundos
        config.backoffMultiplier = 2.0;
        config.retryableErrors = {ERROR_NETWORK, ERROR_TIMEOUT, ERROR_DATABASE};
    }
    
    template<typename Func>
    auto executeWithRetry(Func func, const std::string& operationId) -> decltype(func()) {
        uint32_t attempts = 0;
        uint32_t delay = config.initialDelay;
        
        while (attempts < config.maxAttempts) {
            try {
                return func(); // Executa a fun√ß√£o
            } catch (const std::exception& e) {
                attempts++;
                
                // Verifica se √© um erro retryable
                ErrorInfo error = parseException(e);
                if (!isRetryableError(error.category)) {
                    throw; // Re-throw se n√£o for retryable
                }
                
                if (attempts >= config.maxAttempts) {
                    throw; // Re-throw se excedeu tentativas
                }
                
                // Aguarda antes da pr√≥xima tentativa
                std::this_thread::sleep_for(std::chrono::milliseconds(delay));
                
                // Calcula pr√≥ximo delay com backoff exponencial
                delay = std::min(static_cast<uint32_t>(delay * config.backoffMultiplier), 
                               config.maxDelay);
            }
        }
        
        throw std::runtime_error("Max retry attempts exceeded");
    }
    
private:
    bool isRetryableError(ErrorCategory category) {
        return std::find(config.retryableErrors.begin(), 
                        config.retryableErrors.end(), category) != config.retryableErrors.end();
    }
    
    ErrorInfo parseException(const std::exception& e) {
        // Implementa√ß√£o de parsing de exce√ß√£o
        ErrorInfo error;
        error.category = ERROR_UNKNOWN;
        error.message = e.what();
        error.timestamp = getCurrentTimestamp();
        return error;
    }
    
    uint64_t getCurrentTimestamp() {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();
    }
};
```

#### **üîå Circuit Breaker Pattern**
```cpp
// Implementa√ß√£o do padr√£o Circuit Breaker
class CircuitBreaker {
private:
    enum State {
        CLOSED,     // Funcionando normalmente
        OPEN,       // Circuito aberto (falhas)
        HALF_OPEN   // Testando recupera√ß√£o
    };
    
    State state;
    uint32_t failureThreshold;
    uint32_t successThreshold;
    uint32_t timeoutMs;
    uint32_t failureCount;
    uint32_t successCount;
    uint64_t lastFailureTime;
    
public:
    CircuitBreaker() {
        state = CLOSED;
        failureThreshold = 5;
        successThreshold = 3;
        timeoutMs = 60000; // 1 minuto
        failureCount = 0;
        successCount = 0;
        lastFailureTime = 0;
    }
    
    template<typename Func>
    auto execute(Func func) -> decltype(func()) {
        if (state == OPEN) {
            if (shouldAttemptReset()) {
                state = HALF_OPEN;
            } else {
                throw std::runtime_error("Circuit breaker is OPEN");
            }
        }
        
        try {
            auto result = func();
            onSuccess();
            return result;
        } catch (const std::exception& e) {
            onFailure();
            throw;
        }
    }
    
private:
    void onSuccess() {
        failureCount = 0;
        
        if (state == HALF_OPEN) {
            successCount++;
            if (successCount >= successThreshold) {
                state = CLOSED;
                successCount = 0;
            }
        }
    }
    
    void onFailure() {
        failureCount++;
        lastFailureTime = getCurrentTimestamp();
        
        if (failureCount >= failureThreshold) {
            state = OPEN;
        }
    }
    
    bool shouldAttemptReset() {
        uint64_t now = getCurrentTimestamp();
        return (now - lastFailureTime) >= timeoutMs;
    }
    
    uint64_t getCurrentTimestamp() {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();
    }
};
```

### **üìñ 3. Sistema de Fallback e Degrada√ß√£o**

#### **üîÑ Mecanismos de Fallback**
```cpp
// Sistema de fallback para opera√ß√µes cr√≠ticas
class FallbackManager {
private:
    std::map<std::string, std::function<void()>> fallbackHandlers;
    std::map<std::string, bool> fallbackEnabled;
    
public:
    template<typename Func>
    void registerFallback(const std::string& operation, Func fallbackFunc) {
        fallbackHandlers[operation] = fallbackFunc;
        fallbackEnabled[operation] = true;
    }
    
    void enableFallback(const std::string& operation) {
        fallbackEnabled[operation] = true;
    }
    
    void disableFallback(const std::string& operation) {
        fallbackEnabled[operation] = false;
    }
    
    template<typename Func>
    auto executeWithFallback(const std::string& operation, Func primaryFunc) -> decltype(primaryFunc()) {
        try {
            return primaryFunc();
        } catch (const std::exception& e) {
            if (shouldUseFallback(operation)) {
                return executeFallback(operation);
            }
            throw;
        }
    }
    
private:
    bool shouldUseFallback(const std::string& operation) {
        auto it = fallbackEnabled.find(operation);
        return it != fallbackEnabled.end() && it->second;
    }
    
    auto executeFallback(const std::string& operation) -> decltype(fallbackHandlers[operation]()) {
        auto it = fallbackHandlers.find(operation);
        if (it != fallbackHandlers.end()) {
            return it->second();
        }
        throw std::runtime_error("No fallback handler registered for operation: " + operation);
    }
};

// Exemplo de uso
class DatabaseService {
private:
    FallbackManager fallbackManager;
    
public:
    DatabaseService() {
        // Registra fallback para opera√ß√µes cr√≠ticas
        fallbackManager.registerFallback("getUserData", [this]() {
            return getCachedUserData();
        });
        
        fallbackManager.registerFallback("saveUserData", [this]() {
            return saveToLocalStorage();
        });
    }
    
    UserData getUserData(uint32_t userId) {
        return fallbackManager.executeWithFallback("getUserData", [this, userId]() {
            return queryDatabase(userId);
        });
    }
    
    void saveUserData(const UserData& data) {
        fallbackManager.executeWithFallback("saveUserData", [this, data]() {
            return updateDatabase(data);
        });
    }
    
private:
    UserData queryDatabase(uint32_t userId) {
        // Implementa√ß√£o de query no banco
        throw std::runtime_error("Database connection failed");
    }
    
    UserData getCachedUserData() {
        // Implementa√ß√£o de cache
        return UserData();
    }
    
    void updateDatabase(const UserData& data) {
        // Implementa√ß√£o de update no banco
        throw std::runtime_error("Database update failed");
    }
    
    void saveToLocalStorage() {
        // Implementa√ß√£o de salvamento local
    }
};
```

#### **üìâ Degrada√ß√£o Graciosa**
```cpp
// Sistema de degrada√ß√£o graciosa
class GracefulDegradation {
private:
    struct ServiceLevel {
        std::string name;
        bool enabled;
        uint32_t priority;
        std::function<bool()> healthCheck;
    };
    
    std::vector<ServiceLevel> services;
    
public:
    void registerService(const std::string& name, uint32_t priority, 
                        std::function<bool()> healthCheck) {
        ServiceLevel service;
        service.name = name;
        service.enabled = true;
        service.priority = priority;
        service.healthCheck = healthCheck;
        services.push_back(service);
        
        // Ordena por prioridade
        std::sort(services.begin(), services.end(), 
                 [](const ServiceLevel& a, const ServiceLevel& b) {
                     return a.priority < b.priority;
                 });
    }
    
    void checkSystemHealth() {
        for (auto& service : services) {
            try {
                service.enabled = service.healthCheck();
            } catch (const std::exception& e) {
                service.enabled = false;
                logServiceFailure(service.name, e.what());
            }
        }
    }
    
    std::vector<std::string> getAvailableServices() const {
        std::vector<std::string> available;
        for (const auto& service : services) {
            if (service.enabled) {
                available.push_back(service.name);
            }
        }
        return available;
    }
    
    bool isServiceAvailable(const std::string& name) const {
        for (const auto& service : services) {
            if (service.name == name) {
                return service.enabled;
            }
        }
        return false;
    }
    
private:
    void logServiceFailure(const std::string& serviceName, const std::string& error) {
        // Implementa√ß√£o de logging
        std::cerr << "Service " << serviceName << " failed: " << error << std::endl;
    }
};
```

### **üìñ 4. Logging e Monitoramento**

#### **üìù Sistema de Logging Estruturado**
```cpp
// Sistema de logging estruturado para erros
class ErrorLogger {
private:
    struct LogEntry {
        uint64_t timestamp;
        ErrorCategory category;
        std::string level;
        std::string message;
        std::string operation;
        std::map<std::string, std::string> context;
    };
    
    std::vector<LogEntry> logBuffer;
    size_t maxBufferSize;
    std::string logFilePath;
    
public:
    ErrorLogger(const std::string& filePath = "error.log") 
        : maxBufferSize(1000), logFilePath(filePath) {}
    
    void logError(ErrorCategory category, const std::string& message, 
                 const std::string& operation = "", 
                 const std::map<std::string, std::string>& context = {}) {
        LogEntry entry;
        entry.timestamp = getCurrentTimestamp();
        entry.category = category;
        entry.level = "ERROR";
        entry.message = message;
        entry.operation = operation;
        entry.context = context;
        
        logBuffer.push_back(entry);
        
        // Flush se buffer cheio
        if (logBuffer.size() >= maxBufferSize) {
            flushToFile();
        }
    }
    
    void logWarning(ErrorCategory category, const std::string& message,
                   const std::string& operation = "",
                   const std::map<std::string, std::string>& context = {}) {
        LogEntry entry;
        entry.timestamp = getCurrentTimestamp();
        entry.category = category;
        entry.level = "WARNING";
        entry.message = message;
        entry.operation = operation;
        entry.context = context;
        
        logBuffer.push_back(entry);
    }
    
    void flushToFile() {
        std::ofstream file(logFilePath, std::ios::app);
        if (file.is_open()) {
            for (const auto& entry : logBuffer) {
                file << formatLogEntry(entry) << std::endl;
            }
            file.close();
            logBuffer.clear();
        }
    }
    
private:
    std::string formatLogEntry(const LogEntry& entry) {
        std::stringstream ss;
        ss << "[" << formatTimestamp(entry.timestamp) << "] "
           << "[" << entry.level << "] "
           << "[" << getCategoryName(entry.category) << "] "
           << entry.message;
        
        if (!entry.operation.empty()) {
            ss << " (Operation: " << entry.operation << ")";
        }
        
        if (!entry.context.empty()) {
            ss << " (Context: ";
            for (const auto& pair : entry.context) {
                ss << pair.first << "=" << pair.second << ", ";
            }
            ss.seekp(-2, std::ios::end); // Remove √∫ltima v√≠rgula
            ss << ")";
        }
        
        return ss.str();
    }
    
    std::string formatTimestamp(uint64_t timestamp) {
        auto time = std::chrono::system_clock::from_time_t(timestamp / 1000);
        auto time_t = std::chrono::system_clock::to_time_t(time);
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time_t), "%Y-%m-%d %H:%M:%S");
        return ss.str();
    }
    
    std::string getCategoryName(ErrorCategory category) {
        switch (category) {
            case ERROR_NETWORK: return "NETWORK";
            case ERROR_DATABASE: return "DATABASE";
            case ERROR_VALIDATION: return "VALIDATION";
            case ERROR_AUTHENTICATION: return "AUTH";
            case ERROR_PERMISSION: return "PERMISSION";
            case ERROR_TIMEOUT: return "TIMEOUT";
            case ERROR_RESOURCE: return "RESOURCE";
            case ERROR_LOGIC: return "LOGIC";
            case ERROR_UNKNOWN: return "UNKNOWN";
            default: return "UNKNOWN";
        }
    }
    
    uint64_t getCurrentTimestamp() {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();
    }
};
```

#### **üìä Monitoramento de Erros**
```cpp
// Sistema de monitoramento de erros
class ErrorMonitor {
private:
    struct ErrorMetrics {
        std::map<ErrorCategory, uint32_t> errorCounts;
        std::map<std::string, uint32_t> operationErrors;
        uint32_t totalErrors;
        uint32_t totalWarnings;
        uint64_t lastErrorTime;
        uint64_t lastWarningTime;
    };
    
    ErrorMetrics metrics;
    std::vector<std::function<void(const ErrorInfo&)>> errorHandlers;
    
public:
    void registerErrorHandler(std::function<void(const ErrorInfo&)> handler) {
        errorHandlers.push_back(handler);
    }
    
    void recordError(const ErrorInfo& error) {
        metrics.errorCounts[error.category]++;
        metrics.totalErrors++;
        metrics.lastErrorTime = getCurrentTimestamp();
        
        // Notifica handlers
        for (auto& handler : errorHandlers) {
            try {
                handler(error);
            } catch (const std::exception& e) {
                // Log do erro no handler
            }
        }
    }
    
    void recordWarning(const ErrorInfo& error) {
        metrics.totalWarnings++;
        metrics.lastWarningTime = getCurrentTimestamp();
    }
    
    ErrorMetrics getMetrics() const {
        return metrics;
    }
    
    bool hasHighErrorRate(ErrorCategory category, uint32_t threshold = 10) const {
        auto it = metrics.errorCounts.find(category);
        return it != metrics.errorCounts.end() && it->second > threshold;
    }
    
    double getErrorRate() const {
        uint64_t now = getCurrentTimestamp();
        uint64_t timeWindow = 3600000; // 1 hora
        
        if (now - metrics.lastErrorTime > timeWindow) {
            return 0.0; // Sem erros recentes
        }
        
        // Calcula taxa de erro por hora
        return static_cast<double>(metrics.totalErrors) / (timeWindow / 3600000.0);
    }
    
private:
    uint64_t getCurrentTimestamp() {
        return std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();
    }
};
```

## üéØ **Exerc√≠cios Pr√°ticos**

### **üîß Exerc√≠cio 1: Sistema de Retry com Jitter**
Implemente um sistema de retry com jitter para evitar thundering herd:

```cpp
// Template para implementa√ß√£o
class RetryWithJitter {
private:
    uint32_t maxAttempts;
    uint32_t baseDelay;
    double jitterFactor;
    
public:
    RetryWithJitter(uint32_t attempts = 3, uint32_t delay = 1000, double jitter = 0.1)
        : maxAttempts(attempts), baseDelay(delay), jitterFactor(jitter) {}
    
    template<typename Func>
    auto execute(Func func) -> decltype(func());
    
private:
    uint32_t calculateDelay(uint32_t attempt);
    double getRandomJitter();
};
```

### **üîß Exerc√≠cio 2: Circuit Breaker com M√©tricas**
Crie um circuit breaker que coleta m√©tricas de performance:

```cpp
// Template para implementa√ß√£o
class MetricsCircuitBreaker {
private:
    struct Metrics {
        uint32_t totalRequests;
        uint32_t successfulRequests;
        uint32_t failedRequests;
        uint64_t averageResponseTime;
        double errorRate;
    };
    
    Metrics metrics;
    
public:
    template<typename Func>
    auto execute(Func func) -> decltype(func());
    
    Metrics getMetrics() const { return metrics; }
    double getErrorRate() const { return metrics.errorRate; }
    uint64_t getAverageResponseTime() const { return metrics.averageResponseTime; }
};
```

### **üîß Exerc√≠cio 3: Sistema de Alertas**
Implemente um sistema de alertas baseado em thresholds:

```cpp
// Template para implementa√ß√£o
class AlertSystem {
private:
    struct AlertRule {
        std::string name;
        std::function<bool()> condition;
        std::function<void()> action;
        bool enabled;
    };
    
    std::vector<AlertRule> rules;
    
public:
    void addRule(const std::string& name, std::function<bool()> condition, 
                std::function<void()> action);
    void checkAlerts();
    void enableRule(const std::string& name);
    void disableRule(const std::string& name);
};
```

## üìä **Avalia√ß√£o e Verifica√ß√£o**

### **‚úÖ Checklist de Conclus√£o**
- [ ] Implementou sistema de retry com backoff exponencial
- [ ] Criou circuit breaker pattern funcional
- [ ] Desenvolveu mecanismos de fallback
- [ ] Implementou degrada√ß√£o graciosa
- [ ] Criou sistema de logging estruturado
- [ ] Implementou monitoramento de erros
- [ ] Testou recupera√ß√£o de falhas

### **üéØ Crit√©rios de Avalia√ß√£o**
- **Resili√™ncia**: Sistema se recupera de 90% das falhas
- **Performance**: Overhead de tratamento de erro < 10%
- **Observabilidade**: Logs estruturados e m√©tricas detalhadas
- **Confiabilidade**: Zero perda de dados em falhas
- **Manutenibilidade**: C√≥digo limpo e bem documentado

## üîó **Links Relacionados**

### **üìö M√≥dulos Pr√©-requisitos**
- [[4.2_sincronizacao_dados|M√≥dulo 4.2: Sincroniza√ß√£o de Dados]]
- [[2.7_sistemas_avancados|M√≥dulo 2.7: Sistemas Avan√ßados]]

### **üìö M√≥dulos Relacionados**
- [[4.4_estrategias_teste|M√≥dulo 4.4: Estrat√©gias de Teste]]

### **üîó Documenta√ß√£o T√©cnica**
- [[../habdel/INTEGRATION-006|INTEGRATION-006: Guias de Migra√ß√£o]]
- [[../habdel/INTEGRATION-007|INTEGRATION-007: Tratamento de Erros]]

## üìù **Notas de Implementa√ß√£o**

### **‚ö†Ô∏è Considera√ß√µes Importantes**
1. **Resili√™ncia**: Sempre implemente m√∫ltiplas estrat√©gias de recupera√ß√£o
2. **Observabilidade**: Logs estruturados s√£o essenciais para debugging
3. **Performance**: Minimize overhead do tratamento de erros
4. **Testabilidade**: Teste cen√°rios de falha regularmente

### **üîß Melhorias Futuras**
- Implementar distributed tracing para erros
- Adicionar machine learning para detec√ß√£o de anomalias
- Criar dashboard de monitoramento em tempo real
- Implementar auto-healing para falhas conhecidas

---

> [!success] **M√≥dulo Conclu√≠do**
> ‚úÖ **Status**: M√≥dulo 4.3 - Tratamento de Erros
> üéØ **Pr√≥ximo**: [[4.4_estrategias_teste|M√≥dulo 4.4: Estrat√©gias de Teste]]
> üìö **Progresso**: 3/4 m√≥dulos de integra√ß√£o conclu√≠dos 