# Sistema de Eventos UIWidget

O sistema de eventos do OTClient permite criar interfaces interativas e responsivas atrav√©s de callbacks e manipuladores de eventos que respondem a a√ß√µes do usu√°rio e mudan√ßas de estado.

## üìã √çndice

1. [Vis√£o Geral](#vis√£o-geral)
2. [Tipos de Eventos](#tipos-de-eventos)
3. [Eventos de Mouse](#eventos-de-mouse)
4. [Eventos de Teclado](#eventos-de-teclado)
5. [Eventos de Estado](#eventos-de-estado)
6. [Eventos Customizados](#eventos-customizados)
7. [Propaga√ß√£o de Eventos](#propaga√ß√£o-de-eventos)
8. [Exemplos Pr√°ticos](#exemplos-pr√°ticos)
9. [Melhores Pr√°ticas](#melhores-pr√°ticas)

## üéØ Vis√£o Geral

O sistema de eventos do OTClient funciona atrav√©s de:

- **Callbacks Lua**: Fun√ß√µes definidas no widget que s√£o chamadas quando eventos ocorrem
- **Propaga√ß√£o de Eventos**: Eventos podem "borbulhar" na hierarquia de widgets
- **Preven√ß√£o de Propaga√ß√£o**: Eventos podem ser consumidos para impedir propaga√ß√£o
- **Eventos Personalizados**: Possibilidade de criar eventos espec√≠ficos da aplica√ß√£o

### üîÑ **Fluxo de Eventos**

```
Evento Ocorre ‚Üí Widget Filho ‚Üí Widget Pai ‚Üí Widget Av√¥ ‚Üí ... ‚Üí Root
                     ‚Üì              ‚Üì           ‚Üì
               Pode Consumir   Pode Consumir  Pode Consumir
```

## üé≠ Tipos de Eventos

### üì± **Eventos de Intera√ß√£o**
- Mouse: cliques, movimento, wheel
- Teclado: teclas pressionadas, liberadas
- Foco: ganhou/perdeu foco

### üîÑ **Eventos de Estado**
- Mudan√ßas de propriedades
- Mudan√ßas de texto
- Mudan√ßas de visibilidade

### ‚ö° **Eventos de Sistema**
- Redimensionamento
- Movimenta√ß√£o
- Atualiza√ß√£o de layout

## üñ±Ô∏è Eventos de Mouse

### üéØ **Eventos B√°sicos de Mouse**

```lua
local widget = g_ui.createWidget('UIWidget', parent)

-- Clique simples
widget.onClick = function(widget, mousePos)
    print('Widget clicado na posi√ß√£o:', mousePos.x, mousePos.y)
    return true  -- Consome o evento (impede propaga√ß√£o)
end

-- Duplo clique
widget.onDoubleClick = function(widget, mousePos)
    print('Duplo clique detectado')
    return true
end

-- Bot√£o pressionado
widget.onMousePress = function(widget, mousePos, button)
    if button == MouseLeftButton then
        print('Bot√£o esquerdo pressionado')
        widget:setBackgroundColor('#ff0000')
    elseif button == MouseRightButton then
        print('Bot√£o direito pressionado')
        -- Mostrar menu contextual
    end
    return true
end

-- Bot√£o liberado
widget.onMouseRelease = function(widget, mousePos, button)
    if button == MouseLeftButton then
        print('Bot√£o esquerdo liberado')
        widget:setBackgroundColor('#00ff00')
    end
    return true
end
```

### üèÉ **Eventos de Movimento**

```lua
-- Mouse entrou no widget
widget.onHoverChange = function(widget, hovered)
    if hovered then
        widget:setOpacity(0.8)
        print('Mouse entrou no widget')
    else
        widget:setOpacity(1.0)
        print('Mouse saiu do widget')
    end
end

-- Movimento cont√≠nuo do mouse
widget.onMouseMove = function(widget, mousePos, mouseMoved)
    -- mousePos: posi√ß√£o atual
    -- mouseMoved: delta do movimento
    print('Mouse moveu para:', mousePos.x, mousePos.y)
    print('Delta:', mouseMoved.x, mouseMoved.y)
    return false  -- N√£o consome (permite propaga√ß√£o)
end

-- Roda do mouse
widget.onMouseWheel = function(widget, mousePos, mouseWheel)
    if mouseWheel == MouseWheelUp then
        print('Scroll para cima')
        -- Implementar zoom in ou scroll up
    elseif mouseWheel == MouseWheelDown then
        print('Scroll para baixo')
        -- Implementar zoom out ou scroll down
    end
    return true
end
```

### üéØ **Eventos de Drag and Drop**

```lua
-- Widget pode ser arrastado
widget:setDraggable(true)

-- In√≠cio do arraste
widget.onDragEnter = function(widget, mousePos)
    print('In√≠cio do arraste')
    widget:setOpacity(0.5)
    return true
end

-- Durante o arraste
widget.onDragMove = function(widget, mousePos, mouseMoved)
    print('Arrastando:', mousePos.x, mousePos.y)
    return true
end

-- Fim do arraste
widget.onDragLeave = function(widget, droppedWidget, mousePos)
    print('Fim do arraste')
    widget:setOpacity(1.0)
    return true
end

-- Item solto sobre este widget
widget.onDrop = function(widget, draggedWidget, mousePos)
    print('Item solto:', draggedWidget:getId())
    -- Implementar l√≥gica de drop
    return true
end
```

## ‚å®Ô∏è Eventos de Teclado

### üî§ **Eventos B√°sicos de Teclado**

```lua
local textEdit = g_ui.createWidget('TextEdit', parent)

-- Tecla pressionada
textEdit.onKeyDown = function(widget, keyCode, keyModifiers)
    print('Tecla pressionada:', keyCode)
    
    if keyCode == KeyEnter then
        print('Enter pressionado')
        return true  -- Consome o evento
    elseif keyCode == KeyEscape then
        print('Escape pressionado')
        widget:clearFocus()
        return true
    end
    
    return false  -- Permite processamento padr√£o
end

-- Tecla liberada
textEdit.onKeyUp = function(widget, keyCode, keyModifiers)
    print('Tecla liberada:', keyCode)
    return false
end

-- Tecla pressionada (com repeti√ß√£o autom√°tica)
textEdit.onKeyPress = function(widget, keyCode, keyModifiers)
    -- Este evento se repete automaticamente se a tecla ficar pressionada
    if keyCode == KeyArrowUp then
        -- Navegar para cima
        return true
    elseif keyCode == KeyArrowDown then
        -- Navegar para baixo
        return true
    end
    return false
end
```

### üî£ **Entrada de Texto**

```lua
-- Texto digitado
textEdit.onTextInput = function(widget, text)
    print('Texto digitado:', text)
    -- Validar entrada, aplicar filtros, etc.
    return false  -- Permite processamento padr√£o
end

-- Texto alterado (ap√≥s processamento)
textEdit.onTextChange = function(widget, newText, oldText)
    print('Texto mudou de "' .. oldText .. '" para "' .. newText .. '"')
    
    -- Valida√ß√£o em tempo real
    if string.len(newText) > 50 then
        widget:setText(oldText)  -- Reverte se muito longo
        return true
    end
    
    return false
end
```

### ‚å®Ô∏è **Modificadores de Teclado**

```lua
widget.onKeyDown = function(widget, keyCode, keyModifiers)
    -- Verificar modificadores
    local ctrl = (keyModifiers & KeyboardCtrlModifier) ~= 0
    local shift = (keyModifiers & KeyboardShiftModifier) ~= 0
    local alt = (keyModifiers & KeyboardAltModifier) ~= 0
    
    if ctrl and keyCode == KeyS then
        print('Ctrl+S pressionado - Salvar')
        return true
    elseif ctrl and shift and keyCode == KeyS then
        print('Ctrl+Shift+S pressionado - Salvar Como')
        return true
    elseif alt and keyCode == KeyF4 then
        print('Alt+F4 pressionado - Fechar')
        return true
    end
    
    return false
end
```

## üîÑ Eventos de Estado

### üëÅÔ∏è **Eventos de Visibilidade e Foco**

```lua
-- Mudan√ßa de foco
widget.onFocusChange = function(widget, focused, reason)
    if focused then
        print('Widget ganhou foco, raz√£o:', reason)
        widget:setBorderColor('#0000ff')
    else
        print('Widget perdeu foco')
        widget:setBorderColor('#666666')
    end
end

-- Mudan√ßa de visibilidade
widget.onVisibilityChange = function(widget, visible)
    if visible then
        print('Widget ficou vis√≠vel')
        -- Iniciar anima√ß√µes, carregar dados, etc.
    else
        print('Widget ficou invis√≠vel')
        -- Pausar anima√ß√µes, liberar recursos, etc.
    end
end

-- Widget foi destru√≠do
widget.onDestroy = function(widget)
    print('Widget sendo destru√≠do')
    -- Cleanup, salvar estado, etc.
end
```

### üìê **Eventos de Geometria**

```lua
-- Posi√ß√£o mudou
widget.onGeometryChange = function(widget, oldRect, newRect)
    print('Widget movido/redimensionado')
    print('Rect antigo:', oldRect.x, oldRect.y, oldRect.width, oldRect.height)
    print('Rect novo:', newRect.x, newRect.y, newRect.width, newRect.height)
    
    -- Reagir a mudan√ßas de tamanho
    if newRect.width ~= oldRect.width then
        print('Largura mudou')
        -- Ajustar layout interno
    end
end

-- Layout foi atualizado
widget.onLayoutUpdate = function(widget)
    print('Layout do widget foi atualizado')
    -- Reagir a mudan√ßas de layout
end
```

## ‚ö° Eventos Customizados

### üé® **Criando Eventos Pr√≥prios**

```lua
-- Definir evento customizado
local function fireCustomEvent(widget, eventData)
    if widget.onCustomEvent then
        widget.onCustomEvent(widget, eventData)
    end
end

-- Widget que dispara evento customizado
local dataWidget = g_ui.createWidget('UIWidget', parent)

dataWidget.updateData = function(self, newData)
    self.data = newData
    
    -- Disparar evento customizado
    fireCustomEvent(self, {
        type = 'dataUpdated',
        data = newData,
        timestamp = os.time()
    })
end

-- Widget que escuta evento customizado
dataWidget.onCustomEvent = function(widget, eventData)
    if eventData.type == 'dataUpdated' then
        print('Dados atualizados:', eventData.data)
        print('Timestamp:', eventData.timestamp)
    end
end
```

### üì¢ **Sistema de Eventos Global**

```lua
-- Sistema simples de eventos globais
local EventSystem = {}
EventSystem.listeners = {}

function EventSystem.on(eventName, callback)
    if not EventSystem.listeners[eventName] then
        EventSystem.listeners[eventName] = {}
    end
    table.insert(EventSystem.listeners[eventName], callback)
end

function EventSystem.emit(eventName, data)
    if EventSystem.listeners[eventName] then
        for _, callback in ipairs(EventSystem.listeners[eventName]) do
            callback(data)
        end
    end
end

-- Uso do sistema global
EventSystem.on('playerLevelUp', function(data)
    print('Player subiu para level:', data.newLevel)
end)

-- De qualquer lugar no c√≥digo
EventSystem.emit('playerLevelUp', {newLevel = 50})
```

## üåä Propaga√ß√£o de Eventos

### ‚¨ÜÔ∏è **Bubbling (Propaga√ß√£o para Cima)**

```lua
-- Widget filho
local child = g_ui.createWidget('UIWidget', parent)
child.onClick = function(widget, mousePos)
    print('Clique no filho')
    return false  -- N√ÉO consome - permite propaga√ß√£o
end

-- Widget pai
local parent = g_ui.createWidget('UIWidget', rootWidget)
parent.onClick = function(widget, mousePos)
    print('Clique propagou para o pai')
    return true  -- Consome aqui
end

-- Resultado: ao clicar no filho, ambos os prints aparecer√£o
```

### üõë **Impedindo Propaga√ß√£o**

```lua
local button = g_ui.createWidget('Button', parent)

button.onClick = function(widget, mousePos)
    print('Bot√£o clicado')
    
    -- Processar l√≥gica do bot√£o
    widget:setText('Clicado!')
    
    return true  -- CONSOME o evento - impede propaga√ß√£o
end

-- O widget pai N√ÉO receber√° este evento
parent.onClick = function(widget, mousePos)
    print('Este print nunca aparecer√°')
    return true
end
```

### üîÑ **Eventos Condicionais**

```lua
local conditionalWidget = g_ui.createWidget('UIWidget', parent)

conditionalWidget.onClick = function(widget, mousePos)
    if widget:isEnabled() then
        print('Widget habilitado - processando clique')
        return true  -- Consome
    else
        print('Widget desabilitado - ignorando clique')
        return false  -- Permite propaga√ß√£o
    end
end
```

## üí° Exemplos Pr√°ticos

### üéÆ **Sistema de Menu Contextual**

```lua
local ContextMenu = {}

function ContextMenu.show(widget, items, mousePos)
    local menu = g_ui.createWidget('UIWidget', rootWidget)
    menu:setId('contextMenu')
    menu:setPosition(mousePos)
    menu:setBackgroundColor('#333333')
    menu:setBorderWidth(1)
    menu:setBorderColor('#666666')
    
    local layout = UIVerticalLayout.create(menu)
    menu:setLayout(layout)
    
    for _, item in ipairs(items) do
        local menuItem = g_ui.createWidget('Label', menu)
        menuItem:setText(item.text)
        menuItem:setPadding(5)
        menuItem:setHeight(25)
        
        menuItem.onClick = function()
            if item.callback then
                item.callback()
            end
            menu:destroy()
            return true
        end
        
        menuItem.onHoverChange = function(widget, hovered)
            if hovered then
                widget:setBackgroundColor('#555555')
            else
                widget:setBackgroundColor('#333333')
            end
        end
    end
    
    -- Fechar ao clicar fora
    rootWidget.onMousePress = function(widget, mousePos, button)
        if not menu:containsPoint(mousePos) then
            menu:destroy()
            rootWidget.onMousePress = nil  -- Remove handler
        end
        return false
    end
end

-- Uso do menu contextual
local myWidget = g_ui.createWidget('UIWidget', parent)

myWidget.onMousePress = function(widget, mousePos, button)
    if button == MouseRightButton then
        ContextMenu.show(widget, {
            {text = 'Copiar', callback = function() print('Copiado') end},
            {text = 'Colar', callback = function() print('Colado') end},
            {text = 'Excluir', callback = function() print('Exclu√≠do') end}
        }, mousePos)
        return true
    end
    return false
end
```

### üîç **Sistema de Tooltip Din√¢mico**

```lua
local Tooltip = {}
Tooltip.current = nil

function Tooltip.show(widget, text, delay)
    delay = delay or 500  -- 500ms de delay padr√£o
    
    if Tooltip.current then
        Tooltip.hide()
    end
    
    scheduleEvent(function()
        if widget:isHovered() then  -- Ainda hovering
            local tooltip = g_ui.createWidget('Label', rootWidget)
            tooltip:setId('tooltip')
            tooltip:setText(text)
            tooltip:setBackgroundColor('#000000bb')
            tooltip:setColor('#ffffff')
            tooltip:setPadding(5)
            tooltip:setFont('verdana-9px-antialised')
            
            -- Posicionar pr√≥ximo ao mouse
            local mousePos = g_window.getMousePosition()
            tooltip:setPosition({x = mousePos.x + 10, y = mousePos.y + 10})
            
            Tooltip.current = tooltip
        end
    end, delay)
end

function Tooltip.hide()
    if Tooltip.current then
        Tooltip.current:destroy()
        Tooltip.current = nil
    end
end

-- Adicionar tooltip a qualquer widget
function addTooltip(widget, text, delay)
    widget.onHoverChange = function(widget, hovered)
        if hovered then
            Tooltip.show(widget, text, delay)
        else
            Tooltip.hide()
        end
    end
end

-- Uso
local button = g_ui.createWidget('Button', parent)
button:setText('Hover Me')
addTooltip(button, 'Este √© um bot√£o especial que faz coisas incr√≠veis!', 300)
```

### üìù **Sistema de Valida√ß√£o de Formul√°rio**

```lua
local FormValidator = {}

function FormValidator.create()
    local validator = {
        fields = {},
        rules = {}
    }
    
    function validator:addField(widget, rules)
        self.fields[widget] = rules
        
        -- Valida√ß√£o em tempo real
        widget.onTextChange = function(w, newText, oldText)
            validator:validateField(w, newText)
            return false
        end
        
        -- Valida√ß√£o ao perder foco
        widget.onFocusChange = function(w, focused)
            if not focused then
                validator:validateField(w, w:getText())
            end
        end
    end
    
    function validator:validateField(widget, text)
        local rules = self.fields[widget]
        if not rules then return true end
        
        for _, rule in ipairs(rules) do
            if not rule.validate(text) then
                widget:setBorderColor('#ff0000')
                widget.validationError = rule.message
                return false
            end
        end
        
        widget:setBorderColor('#00ff00')
        widget.validationError = nil
        return true
    end
    
    function validator:validateAll()
        local isValid = true
        for widget, _ in pairs(self.fields) do
            if not self:validateField(widget, widget:getText()) then
                isValid = false
            end
        end
        return isValid
    end
    
    return validator
end

-- Uso do validador
local form = g_ui.createWidget('UIWidget', parent)
local validator = FormValidator.create()

local nameField = g_ui.createWidget('TextEdit', form)
validator:addField(nameField, {
    {
        validate = function(text) return string.len(text) >= 3 end,
        message = 'Nome deve ter pelo menos 3 caracteres'
    }
})

local emailField = g_ui.createWidget('TextEdit', form)
validator:addField(emailField, {
    {
        validate = function(text) return string.find(text, '@') ~= nil end,
        message = 'Email deve conter @'
    }
})

local submitButton = g_ui.createWidget('Button', form)
submitButton:setText('Enviar')
submitButton.onClick = function()
    if validator:validateAll() then
        print('Formul√°rio v√°lido!')
    else
        print('Formul√°rio inv√°lido!')
    end
    return true
end
```

## ‚úÖ Melhores Pr√°ticas

### üéØ **Gerenciamento de Eventos**

```lua
-- ‚úÖ BOM: Use return true/false apropriadamente
widget.onClick = function(widget, mousePos)
    -- Processar evento
    doSomething()
    
    return true  -- Consome evento se processou completamente
    -- return false  -- Permite propaga√ß√£o se outros widgets precisam processar
end

-- ‚úÖ BOM: Limpe event handlers ao destruir widgets
widget.onDestroy = function(widget)
    widget.onMouseMove = nil
    widget.onClick = nil
    -- Liberar outros recursos
end
```

### üöÄ **Performance**

```lua
-- ‚úÖ BOM: Evite criar functions pesadas em eventos frequentes
widget.onMouseMove = function(widget, mousePos, mouseMoved)
    -- Use debouncing para opera√ß√µes pesadas
    if not widget.moveTimeout then
        widget.moveTimeout = scheduleEvent(function()
            expensiveOperation()
            widget.moveTimeout = nil
        end, 100)  -- Executa no m√°ximo a cada 100ms
    end
    return false
end

-- ‚ùå EVITE: Opera√ß√µes pesadas em eventos frequentes
widget.onMouseMove = function(widget, mousePos, mouseMoved)
    -- Esta fun√ß√£o ser√° chamada MUITAS vezes por segundo
    expensiveOperation()  -- ‚ùå Pode causar lag
    return false
end
```

### üîß **Debugging de Eventos**

```lua
-- Sistema de debug para eventos
local function debugEvent(widget, eventName)
    local originalHandler = widget[eventName]
    
    widget[eventName] = function(...)
        print('DEBUG:', widget:getId(), eventName, ...)
        
        if originalHandler then
            return originalHandler(...)
        end
        return false
    end
end

-- Usar para debuggar
debugEvent(myWidget, 'onClick')
debugEvent(myWidget, 'onMouseMove')
```

### üé≠ **Padr√µes de Eventos**

```lua
-- ‚úÖ BOM: Use padr√£o Observer para m√∫ltiplos listeners
local EventEmitter = {}
function EventEmitter:new()
    local obj = {listeners = {}}
    setmetatable(obj, self)
    self.__index = self
    return obj
end

function EventEmitter:on(event, callback)
    if not self.listeners[event] then
        self.listeners[event] = {}
    end
    table.insert(self.listeners[event], callback)
end

function EventEmitter:emit(event, ...)
    if self.listeners[event] then
        for _, callback in ipairs(self.listeners[event]) do
            callback(...)
        end
    end
end

-- Uso
local myWidget = g_ui.createWidget('UIWidget', parent)
local emitter = EventEmitter:new()

emitter:on('click', function() print('Handler 1') end)
emitter:on('click', function() print('Handler 2') end)

myWidget.onClick = function(...)
    emitter:emit('click', ...)
    return true
end
```

O sistema de eventos do OTClient √© poderoso e flex√≠vel, permitindo criar interfaces altamente interativas e responsivas. Use os padr√µes e pr√°ticas adequadas para garantir performance e manutenibilidade do c√≥digo.